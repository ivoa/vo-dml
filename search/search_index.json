{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>VO-DML is defined formally in an IVOA Standard, but that standard concentrates on  the formal definition of the metamodel, whereas this guide is intended to offer practical assistance to those who want to  use VO-DML to create their own data models, and then create code that can serialize those  models to various formats. </p> <p>Linus Torvalds</p> <p>Good programmers worry about data structures and their relationships.</p> <p>The purpose of writing data models is two-fold</p> <ul> <li>It defines concepts for a particular domain in an abstract way that provides a common discourse about meanings within that domain.</li> <li>It provides a machine-readable representation that can be transformed in various ways that allow    instances of the model to be transported, stored and queried.</li> </ul> <p>Start Modelling and learn about model design and why VODML</p>"},{"location":"#features-of-the-vo-dml-tools","title":"Features of the VO-DML tools","text":"<p>The this project defined the VO-DML tools for working with VO-DML data models - the features of these tools include</p> <ul> <li>easy to install - create a dependency on this project rather than checking it out see template</li> <li>model validation</li> <li>model documentation</li> <li>auto-generation of XML, JSON and TAP Schema</li> <li>auto-generation of Java and Python code that serializes according to these schema.</li> </ul>"},{"location":"Binding/","title":"Binding","text":"<p>When generating various products from the VO-DML there is often a choice to be made in translating the VO-DML into a concrete representation - the definition of these choices is called binding.</p> <p>The mechanism for specifying the binding is via an XML file that conforms to the binding schema. A visual representation of the main part of the schema is shown below </p> <p>The binding file can contain bindings for multiple VODML models, so the overall structure is</p> <p><pre><code>&lt;m:mappedModels xmlns:m=\"http://www.ivoa.net/xml/vodml-binding/v0.9.1\"&gt;\n    &lt;model&gt;\n        &lt;name&gt;a&lt;/name&gt;\n        &lt;file&gt;a.vo-dml.xml&lt;/file&gt;\n\n    &lt;/model&gt;\n    &lt;model&gt;\n        &lt;name&gt;b&lt;/name&gt;\n        &lt;file&gt;b.vo-dml.xml&lt;/file&gt;\n        ...\n    &lt;/model&gt;\n        ...\n&lt;/m:mappedModels&gt;\n</code></pre> where each <code>&lt;model&gt;</code> element corresponds to the <code>ModelBinding</code> type in the diagram above.</p>"},{"location":"Binding/#basic-code-generation-parameters","title":"Basic code generation parameters","text":"<ul> <li><code>&lt;java-package&gt;</code> specifies the base Java package for generated code (packages in the VO-DML will create further sub-packages under this).</li> <li><code>&lt;python-package&gt;</code> specifies the base Python package.</li> <li><code>&lt;xml-targetnamespace prefix=\"...\"&gt;</code> specify the XML namespace and prefix for the xml serialization of the model instances.</li> <li><code>&lt;json-baseURI&gt;</code> allow the base URI for the JSON schema to be modified.</li> </ul>"},{"location":"Binding/#type-mapping","title":"Type mapping","text":"<p>It is possible (and indeed necessary for primitiveTypes) to map a VO-DML type to a specific type in the various languages/serializations that the VO-DML tooling can generate.</p> <p>An example of the binding is given below for the primitiveType <code>ivoa:real</code> </p> <pre><code>&lt;type-mapping&gt;\n  &lt;vodml-id&gt;real&lt;/vodml-id&gt;\n  &lt;java-type jpa-atomic=\"true\"&gt;Double&lt;/java-type&gt;\n  &lt;python-type built-in=\"true\"&gt;float&lt;/python-type&gt;\n  &lt;xsd-type&gt;xsd:float&lt;/xsd-type&gt;\n  &lt;json-type built-in=\"true\"&gt;number&lt;/json-type&gt;\n&lt;/type-mapping&gt;\n</code></pre> <p>It is possible to map DataTypes too, although they will most likely need to be mapped to a hand written type in the target language.</p> <p>The binding file for the base IVOA model shows extensive use of the type mapping features, where it is possible to ignore the automated code generation entirely and substitute hand-written code.</p>"},{"location":"Binding/#stylistic-options","title":"Stylistic options","text":""},{"location":"Binding/#xml-serialization","title":"XML serialization","text":""},{"location":"Binding/#isattribute","title":"isAttribute","text":"<p>when serializing to XML, whether the VO-DML attribute is serialized as an XML attribute - the default is to serialize as XML elements.</p>"},{"location":"Binding/#compositionstyle","title":"compositionStyle","text":"<p>in the XML serialization this determines  whether compositions with multiplicities greater than 1 should have a wrapper element - the choices are</p> <ul> <li>wrapped</li> <li>unwrapped</li> </ul> <p>and the default is wrapped.</p>"},{"location":"Binding/#packagehandling","title":"packageHandling","text":"<p>This controls how VO-DML packages are translated into XML namespaces and names - the options are</p> <ul> <li>qualified (the default)</li> <li>ignore</li> </ul> <p>In both cases the  base namespace of the XML serialization is controlled by <code>&lt;xml-targetnamespace prefix=\"...\"&gt;</code> and this option then controls how names are created in this namespace - the \"qualified\" option means that the names are created by prefixing the VO-DML package names to the VO-DML type names using \".\" as a separator - the \"ignore\" option simply used the VO-DML type names without any package prefixes (note that this might result in errors if all names within the model are not unique).</p>"},{"location":"Binding/#json-serialization","title":"JSON serialization","text":""},{"location":"Binding/#lax","title":"lax","text":"<p>whether definitions in the schema model should be \"closed off\" with \"additionalProperties\": false - if a type definition is expected to be extended, then this cannot be done.</p> <p>The default is false which indicates that types should be \"closed off\".</p> <p>In general if a model is expected to be used as a \"base model\" then this should probably be set to true for the model.</p>"},{"location":"Binding/#rdb-mapping-for-tap-schema","title":"RDB mapping for TAP schema","text":"<p>There are various stylistic choices that can be made about how to map a VO-DML model to a relational database. The binding makes these choices concreate for a particular model.</p>"},{"location":"Binding/#schema","title":"Schema","text":"<p>If present then the generated tables will be put in the given schema - otherwise the default is to put the tables in a schema with the same name as the model.</p>"},{"location":"Binding/#inheritance-strategy","title":"Inheritance Strategy","text":"<p>This can either be  * joined * single-table</p> <p>If joined then each sub-type creates a separate table to store its unique attributes. In contrast the single-table strategy has a single table with columns for all of the attributes in the whole class hierarchy. In this second case there needs to be a discriminator column which can have its size specified with <code>discriminatorColumnLength</code></p>"},{"location":"Binding/#naturaljoin","title":"NaturalJoin","text":"<p>If true then primary keys will have a name that includes the table name so that natural joins might be made - otherwise the default is that surrogate primary keys as just called ID. </p>"},{"location":"Binding/#uesrefincolumnname","title":"uesRefInColumnName","text":"<p>if true the column name for a reference will use the referred name in some way (dependent on naturalJoin) rather than simply using the member name as the column name</p>"},{"location":"Binding/#listconcatenationdelimiter","title":"listConcatenationDelimiter","text":"<p>When an attribute has a multiplicity &gt; 1,which is not a favoured model design, but can be supported in the case where the attribute has a simple string representation, then the RDB serialization can be a single column of a delimited string - this attribute allows that delimiter character to be specified for the whole model.</p>"},{"location":"Binding/#mapping-individual-types","title":"Mapping individual types","text":"<p>It is possible to alter the mapping of individualTypes</p> <ul> <li>tableName - the name of the table can be explicitly changed from the default of being the same as the VO-DML name.</li> <li>noTableWhenInComposition - when true, if the type is involved in a composition where maxOccurs = 1 a separate table is not created, but instead it is treated similarly to a DataType - the default is false.</li> </ul>"},{"location":"Commands/","title":"Toolkit commands","text":"<p>The functionality of the tookit is driven by gradle and formally the commands that are available are gradle tasks each of the following should be prefixed with <code>gradle</code> e.g.</p> <p><pre><code>gradle vodmlValidate\n</code></pre> The links in the list below will take you to a more detailed discussion of the task.</p> <ul> <li>UmlToVodml - convert UML to VO-DML</li> <li>vodmlDoc - create documentation for VO-DML models</li> <li>vodmlJavaGenerate - Generate Java classes from VO-DML models</li> <li>vodmlPythonGenerate - generate python classes from VO-DML models</li> <li>vodmlSchema - create schema for VO-DML models</li> <li>vodmlSite - create mkdocs site for VO-DML models</li> <li>vodmlToVodsl - convert VO-DML to VODSL on the commandline</li> <li>vodmlValidate - validate VO-DML models</li> <li>vodmlXsdToVodsl - convert XML schema to VODSL on the commandline</li> <li>vodslToVodml - convert VODSL to VO-DML</li> </ul>"},{"location":"Documentation/","title":"Documentation","text":""},{"location":"Documentation/#individual-files","title":"Individual files","text":"<pre><code>gradle vodmlDoc \n</code></pre> <p>will generate standard documentation into the directory <code>build/generated/docs/vodml/</code> (this can be changed with the <code>outputDocDir</code> setting)</p> <p>This will produce a model diagram, latex and html formatted documentation, as well as a graphml  representation of the model (a file with a <code>.graphml</code> extension) that can be hand edited with yEd for nicer looking model diagrams.</p> <p></p>"},{"location":"Documentation/#site","title":"Site","text":"<pre><code>gradle vodmlSite\n</code></pre> <p>Will generate a whole static site describing the model that is intended to be further processed with mkdocs tool that is configured with the material theme.</p> <p>The site is generated at in the <code>build/generated/docs/vodml-site/</code> directory (which can be  changed with the <code>outputSiteDir</code> setting). If you are creating full documentation site,  then it is likely that you will want to add content other than the autogenerated model  description. In this case the tools have an assumption that the <code>outputSiteDir</code> is set to a <code>generated</code> sub-directory of your configured mkdocs top-level directory.</p> <p>The plugin will create an <code>allnav.yaml</code> file in the project directory which can be added to the mkdocs navigation using <code>yq</code> by adding the following to the <code>build.gradle.kts</code></p> <pre><code>tasks.register&lt;Exec&gt;(\"siteNav\")\n{\n    commandLine(\"yq\", \"-i\",  \"(.nav.[]|select(has(\\\"AutoGenerated Documentation\\\"))|.[\\\"AutoGenerated Documentation\\\"]) += load(\\\"allnav.yml\\\")\", \"mkdocs.yml\")\n    dependsOn(\"vodmlSite\")\n}\n</code></pre> <p>which in turn assumes that there is an \"AutoGenerated Documentation\" section in the mkdocs nav that can be added to.</p> <pre><code>nav:\n  - Home: index.md\n  - AutoGenerated Documentation:\n      - Javadoc: generated/javadoc\n</code></pre> <p>The DataModel Template has an example setup, and the ProposalDM has a mature example with many objects.</p> <p></p>"},{"location":"Installation/","title":"Installation","text":"<p>The VO-DML tooling is based around gradle (currently version 8) which itself is based on Java. It is recommended that a minimum of JDK 17 is installed  using a package manager for your OS and  similarly use a package manager for gradle installation. Although if you are working with a repository that already has a <code>gradelw</code> file at the top level, then that can be used in place of the gradle command, and it will handle the downloading and running of the correct gradle version. </p> <p>The functionality of the tooling is then encapsulated with a gradle plugin which is configured in the quickstart instructions</p>"},{"location":"Installation/#external-dependencies","title":"External dependencies","text":"<p>Note the documentation tasks of the tools that produce the overall model diagram also require that graphviz  be installed. </p> <p>If full documentation site generation is required then mkdocs material theme and plantuml is needed as an external installation dependency along with yq that can be used to automate the mkdocs navigation menu creation.</p>"},{"location":"JavaCodeGeneration/","title":"Java Code Generation","text":"<p>The tooling is capable of generating Java classes that can be used to store instances of the models. The code is annotated to allow JAXB and JPA to operate, which mean that it is easy to  read and write model instances to XML and standard relational databases. It should be noted that the generated code uses java 1.8 constructs.</p> <p>The generated Java code depends on the VO-DML java runtime library, which the plugin will automatically add to the dependencies along with the necessary JAXB and JPA libraries.</p>"},{"location":"JavaCodeGeneration/#generating-the-java-code","title":"Generating The Java code","text":"<p>The command <pre><code>gradle vodmlJavaGenerate\n</code></pre> will generate java code in <code>./build/generated/sources/vodml/java</code> which is on the build classpath and so  <pre><code>gradle build\n</code></pre> will compile and run tests on the generated code. In fact <code>gradle build</code> will  automatically run <code>gradle vodmlJavaGenerate</code> if the code is out of date because the model has been updated.</p>"},{"location":"JavaCodeGeneration/#characteristics-of-the-generated-code","title":"Characteristics of the Generated code","text":"<p>In general the code creates POJOs or data classes - i.e. the classes have very little functionality apart from being stores of the data model. The functionality that they do have is described below.</p>"},{"location":"JavaCodeGeneration/#instance-creation","title":"Instance Creation","text":"<p>To be JPA and JAXB compliant, the classes are Java beans with a no argument constructor, so they can be  default constructed and then getX/setX can be used on the properties.</p> <pre><code>A a = new A();\na.setX(x);\na.setY(y);\n</code></pre> <p>In addition, there are several other ways of creating objects</p>"},{"location":"JavaCodeGeneration/#full-constructor","title":"Full constructor","text":"<p>A constructor with all the possible properties included is</p> <p><pre><code>A a = new A(x,y);\n</code></pre> In addition there is a copy constructor, and for subclasses there is a constructor with arguments that consist of a superclass instance as well as the local members.</p>"},{"location":"JavaCodeGeneration/#fluent","title":"Fluent","text":"<p>Each property has a withX(X x) function</p> <pre><code>A a = new A().withX(x).withY(y);\n</code></pre>"},{"location":"JavaCodeGeneration/#fluent-functional-builder","title":"Fluent functional builder","text":"<p>A static builder that takes a functional argument.</p> <p><pre><code>A a = A.createA( b -&gt; {\n         b.x = x;\n         b.y = y;\n         }\n      );\n</code></pre> It should be noted that this style becomes most desirable when there are attributes  which themselves are of a non-primitive type.</p>"},{"location":"JavaCodeGeneration/#serializing-models","title":"Serializing Models","text":"<p>As well as all the individual Enum, ObjectType, and DataType classes, there is an overall ${modelname}Model class generated, that is intended to act as  a 'container' for the individual elements. This is especially useful in the case where the model has references, as then there are some convenience methods for dealing with the automatic setting of reference IDs if necessary.</p>"},{"location":"JavaCodeGeneration/#functions-for-adding-content","title":"Functions for adding content","text":"<p>For each of the concrete objectTypes in the model there is an overloaded <code>addContent()</code> method, which will add the content to the overall instance and find any references.</p> <p>Once all the content has been added, then there is a <code>processReferences()</code> method which will go through the whole model and automatically assign IDs for any references that do not already have them.</p> <p>At this point the overall model object is suitable to be serialized.</p> <p>On reading in a model instance, it is possible to extract any top level ObjectTypes with the <code>public &lt;T&gt; List&lt;T&gt; getContent(Class&lt;T&gt; c)</code> method.</p> <p>contained references</p> <p>There is some provisional support for \"contained references\" when cloning an object - the API for this  is subject to change, but an example is used in copyTest using the <code>createContext()</code> and <code>updateClonedReferences()</code> methods either side of an object clone with a copy constructor.</p> <p>Finally, there is a static <code>public static boolean hasReferences()</code> method which can be used to check if the model has any references - if it does not then much of the machinery above (apart from the JAXBContext) is necessary, and individual ObjectTypes may be written.</p> <p>The unit tests for this project show most of the various code features being used</p>"},{"location":"JavaCodeGeneration/#xml-serialization","title":"XML Serialization","text":"<p>A static function to create a suitable JAXBContext is present <pre><code>JAXBContext jc = MyModel.contextFactory();\n</code></pre></p>"},{"location":"JavaCodeGeneration/#json-serialisation","title":"JSON Serialisation","text":"<p>The JSON serialization is implemented with the Jackson library</p> <p>A suitable ObjectMapper is obtained with <pre><code>ObjectMapper mapper = MyModel.jsonMapper();\n</code></pre></p>"},{"location":"JavaCodeGeneration/#reading-and-writing-from-rdbs","title":"Reading and Writing from RDBs","text":"<p>The generated code has JPA annotations to allow storing in RDBs with compliant systems.</p> <p>Operations are not in general cascaded into references - so that the references need to be explicitly managed. In most cases this will be the \"natural\" way to do things  for the model - however at creation time it might be inconvenient to do this so that there is a method <code>persistRefs(jakarta.persistence.EntityManager _em)</code> on the model that will do a deep persist of any references in the child objects, which in turn then will allow an error free persist of the content. Note that in general it is only possible to run the persistRefs once all of the content has been added to the model, and only for the first time a reference is created - for subsequent updates of the model it will be necessary to manage the references manually. </p> <p>In general collections are marked for lazy loading, and as a convenience there is a <code>forceLoad()</code> method generated that will do a deep walk of all the collections in a particular type, which will force the loading of the whole instance tree if that is desired.</p> <p>This extra JPA functionality is described by the JPAManipulations interface.</p>"},{"location":"JavaCodeGeneration/#composition-helpers","title":"Composition Helpers","text":"<p>Some convenience methods are created on the object that is the parent of compositions to make dealing with JPA updates easier.</p> <p><pre><code>class X {\n   public void replaceInY(final Y _p) {...}\n}\n</code></pre> Where Y is a composition type and the instance _p is not in the current JPA context (e.g has been deserialized from JSON), then the assuming that the deserialized object contains a valid database key, the member of the composition will be updated in a way that is suitable for a JPA merge.</p> <p>Internally this makes use of another convenience function </p> <p><pre><code>class Y {\n   public void updateUsing ( final Y other){...}\n}\n</code></pre> that will update this with all the values from other.</p>"},{"location":"JavaCodeGeneration/#embeddable-datatypes","title":"Embeddable dataTypes","text":"<p>The most natural way to represent dataTypes in JPA is as embeddable, this means that they do not have a separate \"identity\" and are simply represented as columns within the parent entity table. The problem with this is that JPA does not specifically allow inheritance of embeddables (though nor does it disallow the use).  As a consequence the support for inherited embeddables is not uniform in JPA providers.</p> <p>Hibernate seems to support the concept of embeddable hierarchies reasonably well by naturally using the <code>@MappedSuperclass</code> annotation - although there is an irritation in that  the full flexibility of having optional attributes that are dataTypes is not supported as all columns are  made non-nullable - a bug has been submitted https://hibernate.atlassian.net/browse/HHH-14818</p>"},{"location":"JavaCodeGeneration/#tap-schema","title":"TAP schema","text":"<p>The TAP schema is available as an XML serialization according to the TAPSchemaDM using  <pre><code>Model.TAPSchema();\n</code></pre></p>"},{"location":"JavaCodeGeneration/#testing-models","title":"Testing models","text":"<p>The java runtime has a number of base classes that aid the testing of model instances - there is an example for the mock coords model. Although it is not obvious from the source code presented because most of the behaviour is inherited from the base test class, this test will actually</p> <ul> <li>round trip the model instance to JSON</li> <li>round trip the model instance to XML</li> <li>validate the model instance</li> </ul> <p>simply by running</p> <pre><code>gradle test\n</code></pre> <p>will generate the actual model code (if not already done) and run the tests as long as</p> <p><pre><code>tasks.test {\n    useJUnitPlatform()\n}\n</code></pre> is set up in the <code>build.gradle.kts</code> file.</p>"},{"location":"JavaCodeGeneration/#general-interfaces","title":"General interfaces","text":"<p>Much of the functionality described above is defined in two interfaces ModelManagement an  instance of which can be obtained with the <code>management()</code> method on the model class and ModelDescription an instance of which can be obtained with the <code>description()</code> method on the model class. These interfaces allow generic model handling code to be written.</p>"},{"location":"PythonCodeGeneration/","title":"Python Code Generation","text":"<p>NB The python code generation should currently be regarded as alpha quality in that it does not serialize model instances to something that is interoperable with the Java generated code. Indeed it is not yet guaranteed to be representing the VO-DML model fully.</p>"},{"location":"PythonCodeGeneration/#using","title":"Using","text":"<p>The command <pre><code>gradle vodmlPythonGenerate\n</code></pre> will generate python data classes in the <code>./build/generated/sources/vodml/python</code> directory by default (changeable with the <code>outputPythonDir</code> vodml setting).</p> <p>The code uses xsdata for XML and JSON serialization and SQLAlchemy for the RDB serialization.</p>"},{"location":"PythonCodeGeneration/#environment","title":"environment","text":"<p>Although the code generation itself does not need python, to run any tests in the project  relies on (https://github.com/xvik/gradle-use-python-plugin) to manage python virtualenv (i.e. https://virtualenv.pypa.io/en/latest/index.html - not all the other ones). This creates the virtualenv in venv directory at top level - it does not seem to do that properly, so it is best to do that manually beforehand...</p> <pre><code>gradle pipInstall\n</code></pre> <p>Depends on python 3.10+</p>"},{"location":"PythonCodeGeneration/#testing","title":"testing","text":"<p>The project is set up with a single python test at the moment that can be run with</p> <pre><code>gradle pytest\n</code></pre>"},{"location":"PythonCodeGeneration/#notes","title":"notes","text":"<ul> <li>difficult to make xsdata and SQlAlchemy work together as they both want to use the same typing style - the generated code is using SQLAlchemy legacy style to allow both libraries to work simultaneously with the same dataclasses.</li> <li>VO-DML dataTypes -&gt; composites?  https://docs.sqlalchemy.org/en/20/orm/composites.html#nesting-composites</li> <li>with Dataclasses kw_only attributes seem the only practical route when there is inheritance, otherwise ordering the kw arguments after the others is painful in the code...</li> </ul>"},{"location":"QuickStart/","title":"Configuring the VO-DML Gradle Plugin","text":"<p>Latest published version </p> <p>In general, a new data model should be started in its own git repository and configured as below (see ProposalDM for a complete example separate from this repository).  If starting a completely new data model then the Template DM Project is probably the easiest way to get going.</p> <p>If adapting an existing data model repository then</p> <ol> <li>Edit a <code>build.gradle.kts</code> file with reference to the plugin (note substitute  below) <pre><code>plugins {\n    id(\"net.ivoa.vo-dml.vodmltools\") version \"0.x.x\"\n}\n</code></pre></li> <li>create a <code>settings.gradle.kts</code> - it is possible just to copy the template version and just edit the <code>rootProject.name</code>.</li> <li>create the binding file for the model (see below) for more detail (in fact if you only want to run validation, then the binding file is not necessary).</li> </ol> <p>There is nothing else that needs to be done if the VO-DML files in the default place  (see sample build file for some more  hints on how gradle flexibility allows finding of the files to be configured in a variety of ways). </p> <p>If the configuration is successful then</p> <p><pre><code>gradle vodmlValidate\n</code></pre> will attempt to validate the model and print any errors.</p> <p>If the validation is successful you can produce various derived products. Developing your VO-DML model further is discussed here. </p>"},{"location":"QuickStart/#detailed-configuration","title":"Detailed configuration","text":"<p>The vodml tools are all configured within a  <pre><code>vodml {\n\n}\n</code></pre> section in the <code>build.gradle.kts</code> file.</p> <p>The various sub-properties that can be set are</p> <ul> <li>vodmlDir - the default is <code>src/main/vo-dml</code> <pre><code>vodmlDir.set(file(\"vo-dml\"))\n</code></pre>   will set the directory to be <code>vo-dml</code></li> <li>vodmlFiles - this is set by default to be all the <code>*.vo-dml.xml</code> files in the vodmlDir, but can be individually overridden.</li> <li> <p>bindingFiles - the files that specify the mapping details between the models and the generated code. N.B. there is no default for this setting - if generating code it must be specified.</p> </li> <li> <p>outputDocDir - where the generated documentation is created by the <code>gradle vodmlDoc</code> command- default <code>build/generated/docs/vodml/</code>.</p> </li> <li>outputSiteDir - where the mkdocs suitable model description is created by the <code>gradle vodmlSite</code> command - default <code>build/generated/docs/vodml-site</code>.</li> <li>outputJavaDir - where the generated Java is created - the default is <code>build/generated/sources/vodml/java/</code> and it should not    be necessary to ever alter this as gradle will integrate this automatically into the various source paths.</li> <li>outputSchemaDir - where the XML, JSON and TAP schema are generated to - the default is <code>build/generated/sources/vodml/schema/</code> - this is automatically included in the classpath and the output jar.</li> <li>vocabularyDir the directory where local vocabulary definitions are stored - the default  whatever vodmlDir is set to. See here for more discussion of the use of vocabularies.</li> <li>catalogFile - in general it is not necessary to set this, as the plugin will create a catalogue file automatically from the vodmlDir and vodmlFiles properties (as well as including files in any dependencies that also contain VO-DML models)   A catalogue file is necessary as the rest of the tooling is designed to use only the filename (no path) for inclusions and references.   If it is desired to create a file manually for a special purpose, then the file should have the format as below - it should be noted that all references to model files will have to be specified if this is done. <pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;catalog  xmlns=\"urn:oasis:names:tc:entity:xmlns:xml:catalog\"&gt;  \n   &lt;group  prefer=\"system\" &gt;\n       &lt;uri\n               name=\"IVOA-v1.0.vo-dml.xml\"\n               uri=\"src/main/vo-dml/IVOA-v1.0.vo-dml.xml\"/&gt;\n   &lt;/group&gt;\n&lt;/catalog&gt;\n</code></pre></li> </ul>"},{"location":"QuickStart/#binding-files","title":"Binding Files","text":"<p>The binding file is used to set up some properties for various functions on the model - the most basic of which is that it provides a connection between the model name and the filename which contains the VO-DML model.</p> <pre><code>&lt;m:mappedModels xmlns:m=\"http://www.ivoa.net/xml/vodml-binding/v0.9.1\"&gt;\n&lt;!-- ========================================\nThis is a minimal sample file for mapping VO-DML models to XSD or Java using the gradle tooling\n --&gt;\n\n&lt;model&gt;\n&lt;name&gt;sample&lt;/name&gt;\n&lt;file&gt;Sample.vo-dml.xml&lt;/file&gt;\n&lt;java-package&gt;org.ivoa.dm.sample&lt;/java-package&gt;\n&lt;xml-targetnamespace prefix=\"simp\" &gt;http://ivoa.net/dm/models/vo-dml/xsd/sample/sample&lt;/xml-targetnamespace&gt;\n&lt;/model&gt;\n&lt;/m:mappedModels&gt;\n</code></pre> <p>All of the options possible are described fully in the binding section.</p>"},{"location":"Serialization/","title":"Serialization","text":"<p>The design choices made in the serialization of the models to various formats has been driven by the capabilities of the various libraries/standards that are applicable to the Java generated code. Other language implementations will follow the choices that were made in order to be interoperable.</p> <p>For the serializations (other than the relational database), the general idea is that a \"natural\" serialization for the model has been chosen, in contrast to the approach of MIVOT where the idea is that the model is coerced into a table based model - which of course is similar to the relational  database serialization below. This \"natural\" serialization means that objects are enclosed within their parents to whatever depth  is necessary. The only exception to this is that referenced objects that are not otherwise contained within another object in the model are separated out into their own section early in the  serialization so that they can easily be referenced.</p> <pre><code>classDiagram\n    Model &lt;-- References\n    Model &lt;-- Content</code></pre> <p>The aim of the top level container object is to contain all the referred to objects as well as the general content within a single document. References external to the model would need to be incorporated into the model design with an explicit external reference (hence this proposal for VO-DML 1.1 and ). It should be noted that this is a different methodology to the way that the  XML was produced in the previous (ant based) versions of this tooling, and as such the XML target namespaces have been changed.</p> <p>The schema for the serializations can be created with the <code>gradle vodmlSchema</code> command (more detail).</p>"},{"location":"Serialization/#xml","title":"XML","text":"<p>For the small example model, the overall model object will produce xml like</p> <p><pre><code>&lt;ser:myModelModel xmlns:ser=\"http://ivoa.net/vodml/sample/serialization\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" &gt;\n    &lt;refs&gt;\n        &lt;refa _id=\"MyModel-Refa_1000\"&gt;\n            &lt;val&gt;a value&lt;/val&gt;\n        &lt;/refa&gt;\n        &lt;refb&gt;\n            &lt;name&gt;naturalkey&lt;/name&gt;\n            &lt;val&gt;another val&lt;/val&gt;\n        &lt;/refb&gt;\n    &lt;/refs&gt;\n    &lt;someContent&gt;\n        &lt;zval&gt;some&lt;/zval&gt;\n        &lt;zval&gt;z&lt;/zval&gt;\n        &lt;zval&gt;values&lt;/zval&gt;\n        &lt;con xsi:type=\"ser:Dcont\" &gt;\n            &lt;bname&gt;dval&lt;/bname&gt;\n            &lt;dval&gt;a D&lt;/dval&gt;\n        &lt;/con&gt;\n        &lt;con xsi:type=\"ser:Econt\" &gt;\n            &lt;bname&gt;eval&lt;/bname&gt;\n            &lt;evalue&gt;cube&lt;/evalue&gt;\n        &lt;/con&gt;\n        &lt;ref1&gt;MyModel-Refa_1000&lt;/ref1&gt;\n        &lt;ref2&gt;naturalkey&lt;/ref2&gt;\n    &lt;/someContent&gt;\n&lt;/ser:myModelModel&gt;\n</code></pre> Note that because the integer parts of the id might have come from database indices, which  typically are only unique per table, then the string part of the id is made up from the part of the vodml-id of the type.</p>"},{"location":"Serialization/#json","title":"JSON","text":"<p>JSON does not natively have an equivalent to the XML-ID/IDREF mechanism, however, it is possible to distinguish between  a named object as the value of a field or a string or integer literal value for the same field which could be interpreted as a reference to the object if the data model is known. An <code>_id</code> property is added to referenced types which can then used to make a reference. Unlike the XML case where the ID values need to be unique across the whole document, for the JSON serialization the IDs need only be unique for each type - this makes it somewhat easier to use the native database keys directly.</p> <p><pre><code>{\n  \"MyModelModel\" : {\n    \"refs\" : {\n      \"MyModel:Refa\" : [ {\n        \"_id\" : 1000,\n        \"val\" : \"a value\"\n      } ],\n      \"MyModel:Refb\" : [ {\n        \"name\" : \"naturalkey\",\n        \"val\" : \"another val\"\n      } ]\n    },\n    \"content\" : [ {\n      \"@type\" : \"MyModel:SomeContent\",\n      \"_id\" : 0,\n      \"zval\" : [ \"some\", \"z\", \"values\" ],\n      \"con\" : [ {\n        \"@type\" : \"MyModel:Dcont\",\n        \"_id\" : 0,\n        \"bname\" : \"dval\",\n        \"dval\" : \"a D\"\n      }, {\n        \"@type\" : \"MyModel:Econt\",\n        \"_id\" : 0,\n        \"bname\" : \"eval\",\n        \"evalue\" : \"cube\"\n      } ],\n      \"ref1\" : 1000,\n      \"ref2\" : \"naturalkey\"\n    } ]\n  }\n}\n</code></pre> In general where the type of an object cannot be inferred unambiguously from the model,  a member called <code>@type</code> with the UType as value is added.</p>"},{"location":"Serialization/#relational-databases","title":"Relational Databases","text":"<p>The object relational mapping has been done with the capabilities offered by JPA. The general design  decisions that have been made for the mapping are.</p> <ul> <li> <p>The default inheritance strategy is \"JOINED\" - which means that there will be a table per sub-type that has to be joined. This strategy the default as it allows for the widest application of \"NOT NULL\" constraints within the database, at the expense of more complex joins being required. As an alternative a \"SINGLE_TABLE\" strategy can be adopted, by specifying  <pre><code>        &lt;rdb inheritance-strategy=\"single-table\"/&gt;\n</code></pre> in the binding file for the model.</p> </li> <li> <p>DataTypes become embedded as extra columns within the table.</p> </li> </ul>"},{"location":"Transformers/","title":"Model Transformation","text":"<p>A VO-DML transformation is something that takes the model and expresses it in another way. The parameters that can influence how a particular transformation can occur is specified in a binding.</p>"},{"location":"Transformers/#documentation","title":"Documentation","text":"<p>The most basic form of transformation is to make human-readable documentation.</p>"},{"location":"Transformers/#code-generation","title":"Code Generation","text":"<p>Here the model is transformed into source code in various languages, which can then be used to hold instances of the data model and then serialize in various formats - currently supported</p> <ul> <li>XML</li> <li>JSON</li> </ul> <p>In addition the generated code can serialize model instances to relational databases.</p> <p>The languages supported are;</p> <ul> <li>Java</li> <li>Python</li> </ul>"},{"location":"Transformers/#schema","title":"Schema","text":"<p>The models are also transformed into schema that describe the various serializations. The overall aim of the  VO-DML tooling is to be able to exchange instances of the models between different computer languages, with  all the source code and schema automatically generated.</p> <p>The gradle task</p> <p><pre><code>gradle vodmlSchema\n</code></pre> will generate XML, JSON and TAP schema for the model. The schema will be generated in the directory defined by the <code>outputSchemaDir</code> property (default <code>build/generated/sources/vodml/schema/</code>).</p> <p>The database serialization is described in terms of a TAP schema. The specific  TAP Schema serialization is itself defined in vodml. The XML serialization prefixes all of the column names with the table name and a '.' - this is done because the column names are XMLIDs and the prefix is required to ensure that they IDs are unique in the whole serialization document - The consequence of this is that when creating DDL it is expected that this table name would be removed. There is an initial template xslt that will transform a tap definition into DDL for PostgreSQL - this might need adjusting for your particular environment - in particular it does not deal with DDL schema. </p> <p>The schema files are named by adjusting the suffixes in the following fashion - if the original file is called <code>model.vo-dml.xml</code> </p> <ul> <li><code>model.vo-dml.xsd</code> for the XML Schema</li> <li><code>model.vo-dml.json</code> for the JSON Schema</li> <li><code>model.vo-dml.tap.xml</code> for the TAP Schema</li> </ul> <p>These schema files will automatically be included within the jar file for the model, so that instance validation can be automatically done without reference to external files.</p>"},{"location":"Transformers/#transformation-to-vo-dml","title":"Transformation to VO-DML","text":"<p>The transformation of other data model representations to VO-DML is discussed elsewhere. </p>"},{"location":"VO-DML/","title":"Quick Introduction to VO-DML","text":"<p>The Virtual Observatory Data Modelling Language (VO-DML) is a \"meta-model\" i.e. a language for defining models.</p> <p>The VO-DML Standard discusses in some detail the motivations for creating VO-DML which are summarized below;</p> <ul> <li>Desire to be able to create data models that were easy to re-use in other data models.</li> <li>It needed to be machine-readable and  both \"vendor\" and computer language neural to be able to provide the necessary interoperability.</li> <li>It should be able to express concepts that made clear where normalisation could occur in relational data models.</li> </ul>"},{"location":"VO-DML/#vo-dml-concepts","title":"VO-DML concepts","text":""},{"location":"VO-DML/#type-system","title":"Type System","text":"Type Description Example PrimitiveType Atomic, basic values \"boolean\", \"integer\", \"real\", \"string\" Enumeration A fixed list of named values \"filter_name (U, B, V, R, I).\" DataType Structured types that are treated as single values. They have no unique identity. \"A Point (RA, Dec) or a Quantity (Value + Unit).\" ObjectType Complex entities with a unique identity and lifecycle. An Observation, a Source, or a Telescope."},{"location":"VO-DML/#relationships-and-properties","title":"Relationships and Properties","text":"<p>VO-DML defines how these types connect to one another:</p> <ul> <li>Attributes: Simple properties of a type (e.g., the name of a TargetSource).</li> <li>References: A pointer from one ObjectType to another without \"owning\" it. For example, an Observation references a TargetSource.</li> <li>Composition: A \"composition\" relationship where an ObjectType owns a set (collection) of other objects. If the parent is deleted, the collection is deleted (e.g., a Catalog contains a collection of Entries).</li> <li>Semantic Concept can be used to associate semantics to a model element - eg. stating that an attribute value must be from a particular vocabulary - e.g. the IVOA standard vocabularies</li> </ul>"},{"location":"VO-DML/#model-reuse-and-packages","title":"Model Reuse and Packages","text":"<p>To keep models manageable, VO-DML uses:</p> <ul> <li>Model Import: A mechanism to include types from an existing standard model (e.g., importing the IVOABase data model for basic units and quantities) to ensure consistency. Note that more than one model may be imported.</li> <li>Packages: Logical groupings of related types (similar to folders or namespaces), mainly used to avoid potential naming clashes.</li> </ul>"},{"location":"VO-DML/#other-vo-dml-info","title":"Other VO-DML info","text":""},{"location":"VO-DML/#vo-dml-tools-presentations","title":"VO-DML Tools presentations","text":"<ul> <li>Interop Nov 2021 - start of new tools packaging</li> <li>Interop May 2022 - intro to new VO-DML 1.1 constructs</li> <li>Interop Oct 2022 - serialization and Python cocde generation</li> <li>Interop May 2023 - VO-DML Tools demo</li> </ul>"},{"location":"VO-DML/#vo-dml-11-presentations","title":"VO-DML 1.1 presentations","text":"<ul> <li>Interop Nov 2024</li> </ul>"},{"location":"modelling/CaseHandling/","title":"Character Case Conventions","text":""},{"location":"modelling/CaseHandling/#vo-dml","title":"VO-DML","text":"<p>In general the style guide for VO-DML is that CamelCase is used.</p> <ul> <li>attributes (and other type members)  should start with lowercase letter.</li> <li>ObjectTypes and DataTypes are expected to start with an uppercase letter.</li> </ul>"},{"location":"modelling/CaseHandling/#vo-dml-tools","title":"VO-DML tools","text":"<p>In general the VO-DML tools try to manipulate case as little as possible, but the there are some cases where it is more natural to make changes. These cases are detailed below.</p>"},{"location":"modelling/CaseHandling/#xml-serialization","title":"XML serialization","text":"<ul> <li>when there is an enclosing element for a composition<ul> <li>The enclosing element takes its name from the composition name</li> <li>each element in the composition takes its name from the type of the composition - however, this would lead to a mixture of case styles, so the initial letter of the type is transformed to lowercase.</li> </ul> </li> </ul>"},{"location":"modelling/EclipseVODSL/","title":"Eclipse VODSL Editor","text":"<p>Although it is possible to edit VODSL with any plain text editor as discussed in the introduction, an Eclipse plug-in has been created, that allows VOSDL source to be edited whilst taking advantage of the all the features of the Eclipse that make understanding an navigating the code easier. As well as the expected IDE conveniences of syntax colouring, context sensitive suggestions and ease of navigation, the most important feature of the plug-in are;</p> <ul> <li> <p>Compilation of VODSL to VO-DML.</p> </li> <li> <p>Real-time validation and syntax checking.</p> </li> <li> <p>Navigation via a graphical representation of the model.</p> </li> </ul>"},{"location":"modelling/EclipseVODSL/#vodsl-compilation","title":"VODSL compilation","text":"<p>The plugin will compile any VODSL it finds (files with \u2018.vodsl\u2018 extension) to the output directory specified in the compiler section of the VODSL preferences. The compilation will occur whenever the enclosing project is built, and if \u201cbuild automatically\u201d is set then this will be every time that the VODSL file is saved.</p>"},{"location":"modelling/EclipseVODSL/#the-graphical-view","title":"The Graphical View","text":"<p>The graphical view of the model is implemented in FXDiagram and uses some of the same conventions as the standard graphical representation produced by the VO-DML tools, i.e.\u00a0</p> <ul> <li> <p>subclass relations are represented by red connectors</p> </li> <li> <p>reference relations are represented by green connectors</p> </li> <li> <p>composition relations are represented by blue connectors</p> </li> </ul> <p>The graphical view is opened by right clicking on one of the declarations in the text view of the model and selecting \u201cShow in FXDiagram $\\Rightarrow$ VODSL model\u201d</p> <p></p> <p>The graphical representation of the model is basically read-only in that it is not possible to edit model features in the graphical window. However, as well as visualisation, it can usefully be used for navigation around the model.</p> <p>Navigation in the view is possibly a little un-intuitive - on a Mac the following gestures work</p> <ul> <li> <p>Panning is done with a two finger drag on trackpad.</p> </li> <li> <p>Zooming is done with a two finger pinch gesture.</p> </li> <li> <p>A menu consisting of a ring of icons can be invoked with a two finger   tap - the menu as a range of functions including changing the zoom and   saving the diagram.</p> </li> <li> <p>Double-clicking on a model item in the view will select that item in   the textual view, and conversely, right-clicking in the textual view   and chosing \"Show in FXDiagram\" again will select the item in the   graphical view.</p> </li> </ul>"},{"location":"modelling/EclipseVODSL/#installing-the-eclipse-plugin","title":"Installing the Eclipse plugin","text":"<p>It is generally recommended to install the plugin in its own instance of Eclipse (due to some dependencies that are difficult to find) rather than using the usual eclipse plugin installation mechanisms in a pre-existing eclipse instance. This can be achieved thus;</p> <ol> <li> <p>Ensure that you have a Java 11 or later installed on your machine as     well as graphviz</p> </li> <li> <p>download the eclipse installer https://www.eclipse.org/downloads/</p> </li> <li> <p>Run the eclipse installer and select \"advanced mode\" from the menu     at top right.</p> </li> <li> <p>use the green arrow at the top right to add a new user product with     the following     https://raw.githubusercontent.com/pahjbo/vodsl/master/VODSLEditor.setup</p> </li> <li> <p>select the \"VODSL\" user product and just click next through the     dialogs until you have a running editor.</p> </li> <li> <p>create a new \"general\" project and then create a file with extension     <code>.vodsl</code> - eclipse will prompt whether to convert the project to     \"XText\" - say yes.</p> </li> </ol> <p>The image below shows the above steps being executed.</p> <p></p>"},{"location":"modelling/EclipseVODSL/#development-of-the-vodsl-editor","title":"Development of the VODSL Editor.","text":"<p>The tools associated with the VODSL language are being developed in a GitHub repository https://github.com/pahjbo/vodsl and use XText to implement the language itself as well as the Eclipse integration.</p> <p>[^1]: The eclipse plugin has a small bug in that it will sometimes make the first separation of a name reference with a colon even when the referred to type is in fact in the same model</p>"},{"location":"modelling/ModelStructure/","title":"Model Design Tips","text":"<p>The formal VO-DML standard describes in some detail tha various elements that make up the VO-DML metamodel. This documentation attempts to provide some practical guidance on how to use these elements especially in the context of the way that the VO-DML tooling interprets and makes choices in the expression of various serializations of the models.</p>"},{"location":"modelling/ModelStructure/#objecttype-or-datatype","title":"ObjectType or DataType","text":"<ul> <li>ObjectTypes are expressed as a table in RDB cf DataTypes are typically columns in a table.<ul> <li>In XML and JSON the differences are not so obvious</li> </ul> </li> <li> <p>ObjectTypes can be composed</p> <ul> <li>This will result in foreign key references in RDBs, but in XML and JSON will usually result in child lists.</li> </ul> </li> <li> <p>ObjectTypes have separate identity</p> <ul> <li>Means that they need an identifying key in RDB.<ul> <li>can use the NaturalKey constraint to use an attribute as a key</li> </ul> </li> <li>Though they do not necessarily need an identifying key in XML and JSON unless they are referred to.</li> </ul> </li> </ul>"},{"location":"modelling/ModelStructure/#references","title":"References","text":"<p>On of the key modelling tools in VO-DML is to be able to define a references to other parts of the model.</p>"},{"location":"modelling/ModelStructure/#contained-references","title":"Contained References.","text":""},{"location":"modelling/ModelStructure/#natural-keys","title":"Natural Keys","text":"<p>The ability to set a <code>NaturalKey</code> constraint on an attribute is a new feature of VO-DML 1.1</p> <p><pre><code>&lt;attribute&gt;\n    &lt;vodml-id&gt;Proposal.id&lt;/vodml-id&gt;\n    &lt;name&gt;id&lt;/name&gt;\n    &lt;description&gt;collection-specific identifier for the proposal&lt;/description&gt;\n    &lt;datatype&gt;\n        &lt;vodml-ref&gt;ivoa:string&lt;/vodml-ref&gt;\n    &lt;/datatype&gt;\n    &lt;multiplicity&gt;\n        &lt;minOccurs&gt;1&lt;/minOccurs&gt;\n        &lt;maxOccurs&gt;1&lt;/maxOccurs&gt;\n    &lt;/multiplicity&gt;\n    &lt;constraint xsi:type=\"vo-dml:NaturalKey\"&gt;\n        &lt;position&gt;1&lt;/position&gt;\n    &lt;/constraint&gt;\n&lt;/attribute&gt;\n</code></pre> This can be used to indicate to the database serialization that the attribute should be used as the primary key rather than a surrogate primary key being generated.</p> <p>The <code>&lt;position&gt;</code> element is intended to signify the position in a composite primary key.</p>"},{"location":"modelling/ModelStructure/#composite-primary-keys-from-the-composition-hierarchy","title":"Composite primary keys from the composition hierarchy","text":"<p>If the <code>&lt;position&gt;</code> element of the NaturalKey is set to <code>0</code> then that is used to indicate that a composite primary key should be formed from the NaturalKeys that are defined in the composition hierarchy (and it is expected that there is a NaturalKey in each element up that hierarchy) The implied extra NaturalKeys that make up the composite should not be explicitly signified in the VO-DML.</p>"},{"location":"modelling/ModelStructure/#external-references","title":"External references","text":""},{"location":"modelling/TransformingToVODML/","title":"Creating VO-DML from other Data Models","text":"<p>It is possible to start with an XML schema that can be transferred to VODSL with </p> <pre><code>gradle vodmlXsdToVodsl --xsd `pwd`/mymodel.xsd --dsl mymodel.vodsl\n</code></pre> <p>Note that it is necessary to use the full path for the input file.</p> <p>The transformation does not cope with all of the \"styles\" XML schema that are possible, so that it is likely that the generated VODSL will need further hand editing.</p>"},{"location":"modelling/UML/","title":"UML","text":""},{"location":"modelling/UML/#configuring-the-uml-tool","title":"Configuring the UML tool","text":"<p>In general it is necessary to configure a UML tool with the IVOA \"profile\" to restrict the metamodel to that used by VO-DML.</p> <p>TBC</p>"},{"location":"modelling/UML/#xmi-support-in-the-gradle-tooling","title":"XMI support in the gradle tooling","text":"<p>As there are several UML tools and the XMI produced by each is slightly different, there is not a specific XMI to VO-DML task, but rather a base <code>net.ivoa.vodml.gradle.plugin.XmiTask</code> that can be customized with the correct XSLT in the <code>build.gradle.kts</code></p> <p><pre><code>tasks.register(\"UmlToVodml\", net.ivoa.vodml.gradle.plugin.XmiTask::class.java) {\n    xmiScript.set(\"xmi2vo-dml_MD_CE_12.1.xsl\") // the conversion script - automatically found in the xslt directory\n    xmiFile.set(file(\"models/ivoa/vo-dml/IVOA-v1.0_MD12.1.xml\")) //the UML XMI to convert\n    vodmlFile.set(file(\"test.vo-dml.xml\")) // the output VO-DML file.\n    description = \"convert UML to VO-DML\"\n}\n</code></pre> The available conversion scripts are those in the xslt directory with <code>xmi2vo-dml</code> as part of their name.</p>"},{"location":"modelling/VODSL/","title":"VODSL","text":""},{"location":"modelling/VODSL/#vodsl-support-in-the-gradle-tools","title":"VODSL support in the gradle tools","text":"<p>There is a <code>vodslToVodml</code> task that will convert models authored in vodsl into standard VO-DML.</p> <p>the configurable properties within the vodml extension are;</p> <ul> <li>vodslDir - the default is <code>src/main/vodsl</code></li> <li>vodslFiles - this is set by default to be all the <code>*.vodsl</code> files in the vodslDir, but can be individually set.</li> </ul> <p>the task will write the VO-DML files into the <code>vodmlDir</code></p> <p>Any dependencies that have VO-DML models within them will have their VO-DML automatically converted to VODSL and placed in the <code>build/tmp</code> directory. Any target VODSL files will have to explicitly include the dependencies with a relative path into that directory.</p> <p>If you want to have the VO-DML generated automatically from the VODSL rather than running this task manually, then</p> <p><pre><code>tasks.named(\"vodmlJavaGenerate\") {\n        dependsOn(\"vodslToVodml\")\n}\n</code></pre> in the <code>build.gradle.kts</code> file would run the task before the Java generation for instance.</p>"},{"location":"modelling/VODSL/#creating-vodsl-from-existing-vo-dml","title":"Creating VODSL from existing VO-DML","text":"<p>If it is desired to create VODSL from some existing VO-DML then there is a special task that can be run from the commandline with arguments (i.e. does not have to be configured in the <code>build.gradle</code> file as it would not be a repeated part of the workflow) The task has the <code>--dml</code> parameter to indicate the input VO-DML file and the <code>--dsl</code> parameter to indicate the output VODSL file.</p> <p><pre><code>gradle vodmlToVodsl --dml=models/sample/sample/vo-dml/Sample.vo-dml.xml --dsl=test.vodsl \n</code></pre> The transformation attempts to be faithful, but the generated VODSL is likely to need some manual editing to clean it up. As stated above, this transformation is expected to be a \"one-time\" operation as although the generation of VO-DML from VODSL is well defined, the reverse has some areas of possible ambiguity especially with VO-DML that has been created not using this toolkit.</p>"},{"location":"modelling/VODSL/#vodsl-language","title":"VODSL language","text":"<p>The VODSL language use the same underlying meta-model as VO-DML but uses a mapping to a syntax that makes it easier for humans to write by hand. It uses a general C/Java-like syntax with the following characteristics;</p> <ul> <li> <p>pairs of curly braces representing grouping</p> </li> <li> <p>attribute declarations ending with semi-colons <code>;</code></p> </li> <li> <p>line comments introduced by <code>// comment</code></p> </li> <li> <p>block comments <code>/* comment */</code></p> </li> <li> <p>keywords</p> <pre><code>model,author,include,package,abstract,primitive,dtype,\notype,as,ordered,composition,enum,references,semantic,\nsubset,title,iskey,ofRank\n</code></pre> </li> <li> <p>attibute names precede their types</p> </li> <li> <p><code>\"documentation strings\"</code> are enforced for all types</p> </li> <li> <p>multiplicities are introduced by <code>@</code></p> </li> </ul> <p>The syntax of various parts of the language are described in the following sections. For a fuller description of the semantics of the language, the VO-DML standard itself should be consulted.</p>"},{"location":"modelling/VODSL/#model-declaration","title":"Model Declaration","text":"<p>The model declaration includes the name of the model its version followed by a description and then a number of authors.</p> <pre><code>model example (0.1) \"description here\" \n   author \"Paul Harrison\"\n   author \"An Other\"\n\n   include \"IVOA-v1.0.vodsl\"\n</code></pre> <p>It will almost always be the case that there should be an include statement that includes the standard IVOA VO-DML base model which defines a number of fundamental primitive types. There can be additonal includes to re-use parts of other models.</p>"},{"location":"modelling/VODSL/#packages","title":"Packages","text":"<p>Packages may be used to partition the namespace in a model. Is is not required that all definitions live in a package as there is an assumed \u201cunnamed\u201d which exists at the top-level of the model. Packages may be nested.</p> <pre><code>package p \"package\" {\n    package n \"nested package\" {\n\n    }\n}\n</code></pre> <p>Note that the above fragment is not actually legal without the inner package containing a type definition.</p>"},{"location":"modelling/VODSL/#types","title":"Types","text":"<p>Types are defined by starting with the particular type keyword. Where appropriate this might be preceded by <code>abstract</code> and if the type is a sub-type of another type then after the type name the supertype is indicated with <code>-&gt;</code>.</p> <pre><code>abstract otype ad1 -&gt; base \"an abstract subtype \"{  \n}\n</code></pre>"},{"location":"modelling/VODSL/#primitives","title":"Primitives","text":"<pre><code>primitive angle \"another primitive\"\n</code></pre> <p>note the lack of a semi-colon at the end of this declaration.</p>"},{"location":"modelling/VODSL/#enumerations","title":"Enumerations","text":"<pre><code>enum options \"an enum\" {\n    val1 \"first option\",\n    val2 \"second option\"\n}   \n</code></pre>"},{"location":"modelling/VODSL/#datatypes","title":"DataTypes","text":"<p>DataTypes are defined with the \u201cdtype\u201d keyword. This definition also introduces the syntax for attribute definitions, which are defined between the curly braces of the main DataType definition.</p> <pre><code>dtype myQuant -&gt; ivoa:RealQuantity \"a flagged quantity\" {\n            flag : ivoa:boolean \"the flag\" ;\n}\n</code></pre>"},{"location":"modelling/VODSL/#objecttypes","title":"ObjectTypes","text":"<p>ObjectTypes are defined with the \u201cotype\u201d keyword.</p> <pre><code>otype o1 {\n         /* the following attribute is a 'natural key' for the otype */\n           name : ivoa:string iskey \"the identifier\";\n               bv : ivoa:anyURI  \"Description\";\n            /* note use of ^ to be able to \n                    re-use reserved word.*/ \n            ^author: ivoa:string \"author\"; \n}\n</code></pre> <p>This definition also introduces the <code>iskey</code> attribute modifier to hint to any code generation systems that this attribute should be regarded as a \u201cnatural key\u201d for the ObjectType and used rather than generating a surrogate key.</p>"},{"location":"modelling/VODSL/#multiplicities","title":"Multiplicities","text":"<pre><code>otype multiplicities \"the @ sign introduces a multiplicity\"\n{\n    m1 : ivoa:integer @? \"0 or 1\";\n    m2 : ivoa:integer @* \"0 or many\";\n    m3 : ivoa:integer @+ \"1 or many\";\n    m4 : ivoa:integer @[2] \"twice (as an array?)\";\n}\n</code></pre>"},{"location":"modelling/VODSL/#references-and-compositions","title":"References and Compositions","text":"<p>This example shows the syntax for references and compositions and the difference in their semantics.</p> <pre><code> /*  this referred to otype is not affected by the lifecycle\n   of other instances in the model */\n otype ReferedTo { \n    test1: ivoa:integer \"\";\n }\n\n/* instances of this contained class will only live\n   as long as the containing instance.  */\notype Contained  {\n    test2: ivoa:string \"\";\n }\n\notype RCTest { \n    ref references ReferedTo \"\";\n    contained : Contained @+ as composition \"\";\n}\n</code></pre>"},{"location":"modelling/VODSL/#subsetting","title":"Subsetting","text":"<p>Subsetting is an advanced VO-DML feature, where an attribute of a subtype can be declared to be a particular sub-type of the supertype\u2019s attribute type.</p> <pre><code>otype subs -&gt; base {\n    /* note that the requirement to refer to the q attribute of base */\n   subset base.q as myQuant; //the type of base.q is a supertype of myQuant\n}\n</code></pre>"},{"location":"modelling/VODSL/#scoping","title":"Scoping","text":"<p>Type names need to be brought into scope by including the model where they are defined, and thereafter they can be referred to by prefixing the type name with the model name followed by a colon. Types defined in the same model as where they are referred to do not need this model prefix.</p> <p>If the type is futher namepspaced by packages, then to refer to a type in a package the enclosing package names should be separated by periods. The use of a period to separate name parts is also necessary when referring to an attribute of a type - e.g.\u00a0when subsetting.[^2]</p>"},{"location":"modelling/VODSL/#full-example-of-vo-dsl","title":"Full example of VO-DSL","text":"<p>The following is the full model from which the sections above took snippets.</p> <pre><code>/*\n *  created on 25 Feb 2022 \n */\n\n model example (0.1) \"description here\" \n   author \"Paul Harrison\"\n   author \"An Other\"\n\n   include \"IVOA-v1.0.vodsl\"\n\npackage p \"top level package\" {\n    package n \"nested package\" {\n     primitive angle \"another primitive\"     \n    }\n}\n\nenum options \"an enum\" {\n    val1 \"first option\",\n    val2 \"second option\"\n}   \n\ndtype aQuant -&gt; ivoa:Quantity \"an angle quantity\" {\n            value : p.n.angle  \"angle\";\n}\n\nabstract otype base {\n            q : ivoa:Quantity \"a quantity\";   \n}\n\nabstract otype ad1 -&gt; base \"an abstract subtype \"{  \n}\n\notype o1 {\n         /* the following attribute is a 'natural key' for the otype */\n           name : ivoa:string iskey \"the identifier\";\n               bv : ivoa:anyURI  \"Description\";\n            /* note use of ^ to be able to \n                    re-use reserved word.*/ \n            ^author: ivoa:string \"author\"; \n}\n\ndtype myQuant -&gt; ivoa:RealQuantity \"a flagged quantity\" {\n            flag : ivoa:boolean \"the flag\" ;\n}\n\n/* it should be noted in this example that\n * @* and @+ are not \"recommended\" for attributes - it \n   might be better to use composition of otypes - but this is \n   not always the case */\notype multiplicities \"the @ sign introduces a multiplicity\"\n{\n    m1 : ivoa:integer @? \"0 or 1\";\n    m2 : ivoa:integer @* \"0 or many\";\n    m3 : ivoa:integer @+ \"1 or many\";\n    m4 : ivoa:integer @[2] \"twice (as an array?)\";\n}\n\n /*  this referred to otype is not affected by the lifecycle\n   of other instances in the model */\n otype ReferedTo { \n    test1: ivoa:integer \"\";\n }\n\n/* instances of this contained class will only live\n   as long as the containing instance.  */\notype Contained  {\n    test2: ivoa:string \"\";\n }\n\n/* this example references and contains the above types */\notype RCTest { \n    ref references ReferedTo \"\";\n    contained : Contained @+ as composition \"\";\n}\n\n/* an example of subsetting */\notype subs -&gt; base {\n    /* note that the requirement to refer to the q attribute of base */\n   subset base.q as myQuant; //the type of base.q is a supertype of myQuant\n}\n\n/* an example of the syntax for a constraint */\notype constrained {\n            val : ivoa:integer \"just using a natural language constraint\" \n              &lt; \"greater than 5\" as Natural&gt; ;\n        }\n</code></pre>"},{"location":"modelling/VODSL/#rationale-for-vodsl","title":"Rationale for VODSL","text":"<p>VO-DML is the IVOA standard language for creating data models and the standard document details the reasons behind its creation and the advantages of using such a language over other more general languages such as UML. The standard representation of VO-DML is XML and as such it is difficult to edit model instances directly, especially as the XML is a direct representation of the VO-DML meta model. The most common practice envisaged by the standard is that data models are generally created by visual UML tools and then the UML converted to VO-DML via the XMI interchange format. This approach does work, but it has several disadvantages.</p> <ol> <li> <p>UML tools tend to have poor interoperability despite the standard     XMI interchange format</p> <ul> <li> <p>There needs to be a specialized XMI $\\Rightarrow$ VO-DML   conversion written for each UML tool (and sometimes for each   version of a particular tool).</p> </li> <li> <p>It is difficult to \u201cimport\u201d an existing VO-DML definition into a   particular UML tool.</p> </li> </ul> </li> <li> <p>Because of this poor interoperability between UML tools it is     difficult for authors to collaborate on the creation of a data model</p> <ul> <li> <p>even if they are using the same tool and use XMI in a version   control system, there is</p> </li> <li> <p>if they are using different UML tools, comprehending what might be   small incremental changes in the source becomes impossible.</p> </li> </ul> </li> <li> <p>Commercial UML tools tend to be expensive, and the free ones less     feature rich.</p> </li> </ol> <p>These difficulties were the inspiration for creating VODSL as a new route to producing VO-DML with the following characteristics;</p> <ul> <li> <p>Text based for easy management by version control systems.</p> </li> <li> <p>Concise, so that it is easy for direct comprehension by humans.</p> </li> </ul> <p>The VODSL language and its associated tools are version controlled in GitHub as well as some examples of models expressed in VODSL.</p>"},{"location":"modelling/VODSL/#relationship-to-vo-dml","title":"Relationship to VO-DML","text":"<p>The diagram in the introduction shows the role that VODSL plays in the VO-DML creation ecosystem - The yellow arrows indicate transformations that can be made programmatically between the different formats, and the green arrows indicate ways in which the source can be edited and the tools that can be used to create or edit that particular representation. It shows that VODSL has a similar role to XMI/UML in the creation of VO-DML, although with one significant advantage in that there is an exact transformation VO-DML$\\Rightarrow$VODSL.</p> VODSL UML Easier to perform global refactoring vs Easier to visualise the whole model Instant validation[^1] vs Full validation only after XSLT transformation of XMI Easier to merge contributions from two authors textually vs Rely on UML tool to have model merging facility <p>[^1]: when using the Eclipse plug-in</p>"},{"location":"modelling/VODSL/#references","title":"References","text":"<ul> <li>Initial presentation at IVOA Interop (2014)</li> <li>IVOA note (2022)</li> </ul>"},{"location":"modelling/Validation/","title":"Model Validation","text":"<p>A model can be validated with the </p> <pre><code>gradle vodmlValidate\n</code></pre> <p>command, and clearly if there are no errors then the model is unquestionably valid. However, if there are validation messages it does not necessarily mean that the model is definitely bad - The meaning of messages is discussed in more detail below. When publishing a model that has messages then it is necessary in the accompanying documentation to make clear what actions and choices have been made in mitigation of each of the messages (sometimes a complete \"override\" might be justified by the use of a custom type mapping in binding).</p>"},{"location":"modelling/Validation/#validation-messages","title":"Validation Messages","text":"<p>Validation is done using schematron, which although quite powerful in its ability to detect patterns in the VO-DML, is rather limited in the way that messages can be displayed. This can cause some issues with interpretation of the messages, which this guide aims to clarify.</p> <p>The validation messages can be divided into two categories</p> <ul> <li>fatal - must be corrected</li> <li>non-fatal - need some mitigation</li> </ul>"},{"location":"modelling/Validation/#fatal","title":"Fatal","text":"<p>TBC</p>"},{"location":"modelling/Validation/#non-fatal","title":"Non-Fatal","text":"<p>TBC</p>"},{"location":"modelling/Vocabularies/","title":"Vocabularies","text":"<p>VO-DML supports vocabularies via the <code>&lt;semanticconcept&gt;</code> construct which can reference a vocabulary with its <code>&lt;vocabularyURI&gt;</code> element.</p> <p>The tooling will add support for vocabularies in the generated Java code in that it generates code that checks if the values of attribute with an attached vocabulary does actually only contain terms from the vocabulary. There is support for the IVOA vocabularies that are published at https://www.ivoa.net/rdf/, but the tooling currently only supports the IVOA specific desise format.</p>"},{"location":"modelling/Vocabularies/#local-vocabularies","title":"Local Vocabularies","text":"<p>It might be the case that the vocabulary that is desired is not yet sufficiently mature to be published to the IVOA web site, or that it is desired that the vocabulary only ever be applicable to the current VO-DML model. In this circumstance the tooling is able to support local vocabularies (which still must be written in desise)</p> <p>In order to reference a local vocabulary a special URN is used of the form</p> <p><pre><code>urn:vo-dml:MyModel!vocab:myvocab\n</code></pre> where <code>MyModel</code> is the model name and <code>myvocab</code> is the vocabulary name.</p> <p>This will instruct the tooling to look for a <code>myvocab.json</code> file in the <code>vocabularyDir</code> (which is by default the same directory as where the VO-DML files are found) of the MyModel model.</p> <p>The vocabulary will then be added to the jar that is built.</p>"},{"location":"modelling/designIntro/","title":"Designing Models","text":"<p>Creating \"good\" data model designs is an art rather than a science. Within the context of the IVOA reusing existing recommended models is a prerequisite for a model be considered good.</p> <p>The initial test as to whether a model is good is to run validation which will point out areas of the design that need to be carefully considered as well as outright errors.</p>"},{"location":"modelling/designIntro/#purpose-of-the-model","title":"Purpose of the Model","text":"<p>The intended purpose of the model will affect the overall design </p> <ul> <li>Data Discovery</li> <li>Data Labelling</li> <li>Data Modelling.</li> </ul>"},{"location":"modelling/designIntro/#testing-serialization","title":"Testing serialization.","text":"<p>The java runtime has some functionality for roundtrip testing the various serializations  which can be a good first level test as to whether your model is a \"good design\".</p>"},{"location":"modelling/modellingIntro/","title":"Writing VO-DML Models","text":""},{"location":"modelling/modellingIntro/#authoring-ecosystem","title":"Authoring Ecosystem","text":"<p>Although VO-DML/XML is the standard serialization of VO-DML models, and it is possible to create VO-DML directly by editing in a text editor (and the model schema might be helpful in guiding this editing), it is generally easier to model using either</p> <ul> <li>VODSL</li> <li>UML</li> </ul> <p>It is possible to import existing data models by;</p> <ol> <li>Adding the published jar as a dependency in the <code>build.gradle.kts</code> file, e.g. <pre><code>dependencies {\n    implementation(\"net.ivoa.vo-dml:ivoa-base:1.0-SNAPSHOT\")\n}\n</code></pre> the tooling then makes sure that the model files are available for local import.</li> <li> <p>Importing into the model file, and there are two cases whether VO-DML or VODSL is considered the 'working source'</p> <ol> <li> <p>VO-DML - the tooling only requires the file name (it automatically creates an XML catalog which can resolve to  the absolute path) <pre><code>&lt;import&gt;\n    &lt;name&gt;ivoa&lt;/name&gt;\n    &lt;url&gt;IVOA-v1.0.vo-dml.xml&lt;/url&gt;\n&lt;/import&gt;\n</code></pre></p> </li> <li> <p>VODSL - a relative path import should be used - the tooling automatically creates a vodsl file to import into the <code>build/tmp</code> directory so that the    exact form of the relative path depends on where the including source file is located. <pre><code>include \"../../build/tmp/IVOA-v1.0.vodsl\"\n</code></pre></p> </li> </ol> </li> </ol>"}]}