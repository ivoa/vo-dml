<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE stylesheet [
<!ENTITY cr "<xsl:text>
</xsl:text>">
<!ENTITY bl "<xsl:text> </xsl:text>">
]>

<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:vo-dml="http://www.ivoa.net/xml/VODML/v1"
                xmlns:vf="http://www.ivoa.net/xml/VODML/functions"
                xmlns:exsl="http://exslt.org/common"
                xmlns:map="http://www.ivoa.net/xml/vodml-binding/v0.9"
                xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                extension-element-prefixes="exsl"
                exclude-result-prefixes="map" 
                >
<!-- 
  This XSLT script transforms a data model in VO-DML/XML representation to 
  Python dataclasses

  N.B this script is fragile to indentation (because of python - there should probably be a better way to get indentation to work)

  Only defines fields for components.
  Only argumentless constructor.
  
  Python 3.7
  
  Paul Harrison (JBO)
-->

  <xsl:import href="common-binding.xsl"/>

 

  <xsl:output method="text" encoding="UTF-8" indent="yes" />
  <xsl:output name="packageInfo" method="html" encoding="UTF-8" doctype-public="-//W3C//DTD HTML 4.01 Transitional//EN"/>
    <xsl:output name="packageInfoJ" method="text" encoding="UTF-8"/>

  <xsl:strip-space elements="*" />


  <xsl:param name="lastModified"/>
  <xsl:param name="lastModifiedText"/>
  <xsl:param name="output_root" />
  <xsl:param name="vo-dml_package" select="'org.ivoa.vodml.model'"/>
  <xsl:param name="binding"/>
    <xsl:param name="isMain"/>


    <xsl:variable name="vodmlauthor" select="'@author generated by https://github.com/ivoa/vo-dml tools'"/>
    <xsl:variable name="lt">&lt;</xsl:variable>
    <xsl:variable name="gt">&gt;</xsl:variable>
  <xsl:variable name="mapping">
  <xsl:message>setting mapping</xsl:message>
    <map:mappedModels>
      <xsl:for-each select="tokenize($binding,',')">
      <xsl:message><xsl:value-of select="."/></xsl:message>
          <xsl:copy-of
                  select="document(normalize-space(.))/map:mappedModels/model" />
      </xsl:for-each>
    </map:mappedModels>
  </xsl:variable>
 
 <!-- load all models at start -->
  <xsl:variable name="models">
     <xsl:message>setting models</xsl:message>
      <xsl:for-each select="$mapping/map:mappedModels/model">
         <xsl:choose>
            <xsl:when test="file"> <!-- prefer local file for reading defn -->
            <xsl:message>opening file <xsl:value-of select="file"/></xsl:message>
               <xsl:copy-of
                  select="document(file)/vo-dml:model" />
            </xsl:when>
            <xsl:when test="url">
               <xsl:copy-of
                  select="document(url)/vo-dml:model" />
            </xsl:when>
            <xsl:otherwise>
               <xsl:message>Model <xsl:value-of select="vodml-id" />has neither url nor file, hence no artifacts will be generated.</xsl:message>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:for-each>
   </xsl:variable>
 

  <!-- next could be parameters -->


  <!-- main pattern : processes for root node model -->
  <xsl:template match="/">
  <xsl:message >Generating Python - considering models <xsl:value-of select="string-join($models/vo-dml:model/name,' and ')" /></xsl:message>
  <xsl:apply-templates/>
 </xsl:template>

  <!-- model pattern : generates gen-log and processes nodes package and generates the ModelVersion class and persistence.xml -->
  <xsl:template match="vo-dml:model">
    <xsl:message>
-------------------------------------------------------------------------------------------------------
-- Generating Python code for model <xsl:value-of select="name"/> [<xsl:value-of select="title"/>].
-- last modification date of the model <xsl:value-of select="lastModified"/>
-------------------------------------------------------------------------------------------------------
    </xsl:message>

    <xsl:variable name="prefix" select="name"/>
      <xsl:if test="not($mapping/map:mappedModels/model[name=$prefix])">
          <xsl:message terminate="yes">
              There is no binding for model <xsl:value-of select="$prefix"/>
          &cr;
          </xsl:message>
      </xsl:if>
      <xsl:variable name="root_package" select="$mapping/map:mappedModels/model[name=$prefix]/java-package"/>
      <xsl:variable name="root_package_dir" select="replace($root_package,'[.]','/')"/>

      <!--
          <xsl:message>root_package = <xsl:value-of select="$root_package"/></xsl:message>
          <xsl:message>root_package_dir = <xsl:value-of select="$root_package_dir"/></xsl:message>
       -->


<!--       <xsl:apply-templates select="." mode="modelClass">-->
<!--          <xsl:with-param name="root_package" select="$root_package"/>-->
<!--          <xsl:with-param name="root_package_dir" select="$root_package_dir"/>-->
<!--      </xsl:apply-templates>-->

      <xsl:apply-templates select="." mode="content">
      <xsl:with-param name="dir" select="$root_package_dir"/>
      <xsl:with-param name="path" select="$root_package"/>
    </xsl:apply-templates>
  </xsl:template>




  <xsl:template match="vo-dml:model|package" mode="content">
    <xsl:param name="dir"/>
    <xsl:param name="path"/>

    <xsl:variable name="newdir">
      <xsl:choose>
        <xsl:when test="$dir and ./name() = 'package'">
          <xsl:value-of select="concat($dir,'/',name)"/>
        </xsl:when>
        <xsl:when test="$dir and ./name() = 'vo-dml:model'">
          <xsl:value-of select="$dir"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="name"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
   
    <xsl:variable name="newpath">
      <xsl:choose>
        <xsl:when test="$path and ./name() = 'package'">
          <xsl:value-of select="concat($path,'.',name)"/>
        </xsl:when>
        <xsl:when test="$path and ./name() = 'vo-dml:model'">
          <xsl:value-of select="$path"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="name"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
   
    <xsl:message>package = <xsl:value-of select="$newpath"></xsl:value-of></xsl:message>

      <xsl:apply-templates select="." mode="packageDesc">
          <xsl:with-param name="dir" select="$newdir"/>
          <xsl:with-param name="path" select="$newpath"/>
      </xsl:apply-templates>


      <xsl:apply-templates select="objectType|dataType|enumeration|primitiveType" mode="file">
      <xsl:with-param name="dir" select="$newdir"/>
      <xsl:with-param name="path" select="$newpath"/>
    </xsl:apply-templates>

    <xsl:apply-templates select="package" mode="content">
      <xsl:with-param name="dir" select="$newdir"/>
      <xsl:with-param name="path" select="$newpath"/>
    </xsl:apply-templates>

  </xsl:template>


  <xsl:template match="objectType|dataType|enumeration|primitiveType" mode="file">
    <xsl:param name="dir"/>
    <xsl:param name="path"/>

    <xsl:variable name="vodml-id" select="vodml-id" />
    <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
    <xsl:variable name="mappedtype">
      <xsl:call-template name="findmappingInThisModel">
        <xsl:with-param name="modelname" select="./ancestor::vo-dml:model/name"/>
        <xsl:with-param name="vodml-id" select="$vodml-id"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:choose>
    <xsl:when test="not($mappedtype) or $mappedtype = ''" >
      <xsl:variable name="file" select="concat($output_root, '/', $dir, '/', name, '.py')"/>

    <!-- open file for this class -->
      <xsl:message >Writing to Class file <xsl:value-of select="$file"/> base=<xsl:value-of select="vf:baseTypes($vodml-ref)/name"/> haschildren=<xsl:value-of select="vf:hasSubTypes($vodml-ref)"/> contained=<xsl:value-of select="vf:isContained($vodml-ref)"/> referredto=<xsl:value-of select="vf:referredTo($vodml-ref)"/> </xsl:message>
      
      <xsl:result-document href="{$file}">
        <xsl:apply-templates select="." mode="class">
          <xsl:with-param name="path" select="$path"/>
        </xsl:apply-templates>
      </xsl:result-document>
    </xsl:when>
      <xsl:otherwise>
       <xsl:message>1) Mapped type for <xsl:value-of select="$vodml-ref"/> = '<xsl:value-of select="$mappedtype"/>'</xsl:message>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

    <xsl:template match="objectType|dataType|primitiveType|enumeration" mode="typeimports">
from dataclasses import dataclass
    <xsl:for-each select="attribute|reference|composition">
        <xsl:variable name="type" select="datatype/vodml-ref"/>
        <xsl:if test="not(vf:isPythonBuiltin($type))">
import <xsl:value-of select="vf:PythonType($type)"/>
        </xsl:if>
    </xsl:for-each>
        <xsl:if test="extends">
import <xsl:value-of select="vf:PythonType(extends/vodml-ref)"/>
        </xsl:if>
<xsl:text>

</xsl:text>
    </xsl:template>


    <!-- returns the vodml-refs of the members including inherited ones -->
    <xsl:template name="allInheritedMembers" as="xsd:string*">
        <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
        <xsl:variable name="subsets" select="vf:subSettingInSuperHierarchy($vodml-ref)/role/vodml-ref" as="xsd:string*"/>
        <xsl:variable name="supers" select="(.,vf:baseTypes($vodml-ref))"/>
<!--        <xsl:message>inherited <xsl:value-of select="concat($vodml-ref, ' subsets=',string-join($subsets,','),' members=',-->
<!--        string-join(for $v in ($supers/attribute,$supers/composition,$supers/reference) return vf:asvodmlref($v), ',') )" /></xsl:message>-->
        <xsl:sequence>
            <xsl:for-each select="$supers/attribute,$supers/composition,$supers/reference">
                <xsl:variable name="m" select="vf:asvodmlref(.)"/>
                <xsl:if test="not($m = $subsets)">
                  <xsl:value-of select="$m"/>
                </xsl:if>
            </xsl:for-each>
        </xsl:sequence>
    </xsl:template>


    <!-- generate a all member constructor
      The general tactic is to look for all supertype members and initialize them in the one constructor, because it
       is easier to generate than calling super constructors with their appropriate parameters.
    -->
    <xsl:template match="objectType|dataType" mode="constructor">
        <xsl:variable name="subsetsInSubtypes" select="vf:subSettingInSubHierarchy(vf:asvodmlref(current()))/role/vodml-ref" as="xsd:string*"/>

        <xsl:variable name="members" as="xsd:string*"  >
            <xsl:call-template name="allInheritedMembers" />
        </xsl:variable>
        <xsl:variable name="subsets" select="vf:subSettingInSuperHierarchy(vf:asvodmlref(current()))" as="element()*" />

        <xsl:variable name="decls" as="xsd:string*">
                <xsl:for-each select="$members">
                    <xsl:variable name="m" select="$models/key('ellookup',current())"/>
<!--                    <xsl:message>constructor member=<xsl:value-of select="concat(current(),' ',name($m),' insubs=',name($m)='attribute' and current() = $subsetsInSubtypes,' subs=',string-join($subsetsInSubtypes,','))"/> </xsl:message>-->
                    <xsl:if test="not(name($m)='attribute' and current() = $subsetsInSubtypes)">
                <xsl:value-of>
                    <xsl:text>final </xsl:text>
                            <xsl:apply-templates select="$m" mode="paramDecl"/>
                </xsl:value-of>
                    </xsl:if>


                </xsl:for-each>
                <xsl:for-each select="$subsets">
                    <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
                    <xsl:variable name="name" select="tokenize(role/vodml-ref, '[.]' )[last()]"/>
                    <xsl:choose>
                        <xsl:when test="$models/key('ellookup',current()/role/vodml-ref)/multiplicity[maxOccurs != 1]">
                            <xsl:value-of select="concat('final java.util.List', $lt, $type, $gt, ' ', $name)"/>
                        </xsl:when>
                        <xsl:otherwise>
                            <xsl:value-of select="concat('final ',$type, ' ', $name)"/>
                        </xsl:otherwise>
                    </xsl:choose>

                </xsl:for-each>
        </xsl:variable>
        <xsl:if test="count($decls) > 0">
        /**
        * full parameter constructor.
            <!-- TODO get the parameter descriptions again - not DRY unfortunately-->
            <xsl:for-each select="$decls">
        *   @param <xsl:value-of select="tokenize(current(),' ')[last()]"    />
            </xsl:for-each>
        */
        public  <xsl:value-of select="name"/> (
          <xsl:value-of select="string-join($decls,', ')"/>
        )
        {
           <xsl:for-each select="$decls">
             <xsl:variable name="n" select="tokenize(current(),' ')[last()]"  />
           this.<xsl:value-of select="$n"/> = <xsl:value-of select="$n"/>;
           </xsl:for-each>
          }
        </xsl:if>
    </xsl:template>

  <xsl:template match="attribute|composition|reference" mode="paramDecl">
      <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
      <xsl:choose>
          <xsl:when test="name()='composition' and multiplicity/maxOccurs != 1" >
              <xsl:choose>
                  <xsl:when test="vf:isSubSetted(vf:asvodmlref(.))">
                      <xsl:value-of select="concat(name,' : list[',$type, '] ')" />
                  </xsl:when>
                  <xsl:otherwise>
                      <xsl:value-of select="concat(name,' : list[',$type, '] ')" />
                  </xsl:otherwise>
              </xsl:choose>

          </xsl:when>
          <xsl:otherwise>
              <xsl:choose>
                  <xsl:when test="xsd:int(multiplicity/maxOccurs) gt 1">
                      <xsl:value-of select="concat(name,' : array[',$type, '] ')" />
                  </xsl:when>
                  <xsl:when test="multiplicity/maxOccurs = -1">
                      <xsl:value-of select="concat(name,' : list[',$type, '] ')" />
                  </xsl:when>
                  <xsl:otherwise>
                      <xsl:value-of select="concat(name, ': ',$type)" />
                  </xsl:otherwise>
              </xsl:choose>

          </xsl:otherwise>
      </xsl:choose>

  </xsl:template>

    <!-- template class creates a java class (JPA compliant) for UML object & data types -->
  <xsl:template match="objectType|dataType" mode="class">
    <xsl:param name="path"/>
    <xsl:variable name="vodml-ref"><xsl:apply-templates select="vodml-id" mode="asvodml-ref"/></xsl:variable>
    <!-- imports -->
    <xsl:if test="composition">
    <!-- nothing special yet -->
    </xsl:if>
    <xsl:apply-templates select="." mode="typeimports"/>
    <xsl:call-template name="vodmlAnnotation"/>
@dataclass
class <xsl:value-of select="name"/>
      <xsl:if test="extends"><xsl:value-of select="concat('(',vf:PythonType(extends/vodml-ref),')')"/></xsl:if>:
    """
    * <xsl:apply-templates select="." mode="desc" />
    *
    * <xsl:value-of select="name()"/>: &bl;<xsl:value-of select="name" />
    *
    * <xsl:value-of select="$vodmlauthor"/>
    """
      <xsl:if test="local-name() eq 'objectType' and not (extends) and not(attribute/constraint[ends-with(@xsi:type,':NaturalKey')])" >

          <xsl:if test="vf:referredTo($vodml-ref)">
           </xsl:if>

      </xsl:if>
<!-- 
      /** serial uid = last modification date of the UML model */
      private static final long serialVersionUID = LAST_MODIFICATION_DATE;
 -->
      <xsl:apply-templates select="attribute" mode="declare" />
      <xsl:apply-templates select="constraint[ends-with(@xsi:type,':SubsettedRole')]" mode="declare" />
      <xsl:apply-templates select="composition" mode="declare" />
      <xsl:apply-templates select="reference" mode="declare" />
<!--      <xsl:apply-templates select="." mode="constructor"/>-->


      <xsl:if test="vf:referredTo($vodml-ref) and attribute/constraint[ends-with(@xsi:type,':NaturalKey')]">
          <!--TODO deal with multiple natural keys -->
          <!-- TODO this assumes that the natural key is a string -->

      </xsl:if>

      <xsl:if test="not(@abstract)">
      </xsl:if>
  </xsl:template>




  <xsl:template match="enumeration" mode="class">
    <xsl:param name="dir"/>
    <xsl:param name="path"/>
      <xsl:text>from enum import Enum


class </xsl:text><xsl:value-of select="concat(name,'(Enum):')"/>
    """
    * <xsl:apply-templates select="." mode="desc" />
    *
    * Enumeration <xsl:value-of select="name"/> :
    *
    * <xsl:value-of select="$vodmlauthor"/>
    """
<xsl:apply-templates select="literal"  />
&cr;
   </xsl:template>

  <xsl:template match="primitiveType" mode="class">
    <xsl:param name="path"/>

    <xsl:variable name="valuetype">
      <xsl:choose>
        <xsl:when test="extends">
          <xsl:value-of select="vf:PythonType(extends/vodml-ref)"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:message>Primitive type <xsl:value-of select="name"/> is being represented as a String - in general it is probably best to specialize primitive types with the binding mechanism to get desired representation/behavious</xsl:message>
            <xsl:value-of select="'String'"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
        <xsl:apply-templates select="." mode="typeimports" />
<!---->

      <xsl:call-template name="vodmlAnnotation"/>
  @dataclass
  class <xsl:value-of select="name"/>:
      """
      *  <xsl:apply-templates select="." mode="desc" />
      *  PrimitiveType <xsl:value-of select="name"/> :
      *
      *  <xsl:value-of select="$vodmlauthor"/>
      """

      value: <xsl:value-of select="$valuetype"/>


  </xsl:template>


    <xsl:template match="attribute" mode="declare">
        <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
        <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
        <xsl:if test="not(vf:isSubSetted($vodml-ref))">
            <xsl:text>
    </xsl:text>
            <xsl:call-template name="vodmlAnnotation"/>
            <xsl:choose>
                <xsl:when test="xsd:int(multiplicity/maxOccurs) gt 1">
                    <xsl:value-of select="concat(name, ': array[',$type,']')"/>
                </xsl:when>
                <xsl:when test="xsd:int(multiplicity/maxOccurs) lt 0">
                    <xsl:value-of select="concat(name, ': list[',$type,']')"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:value-of select="concat(name,': ',$type)"/>
                </xsl:otherwise>
            </xsl:choose>
    """
     Attribute <xsl:value-of select="name"/> : multiplicity <xsl:apply-templates select="multiplicity" mode="tostring"/>
        <xsl:apply-templates select="." mode="desc"/>
    """
        </xsl:if>
    </xsl:template>


    <xsl:template match="constraint[ends-with(@xsi:type,':SubsettedRole')]" mode="declare">
        <!-- FIXME subsets can also be of compositions and references - worry about multiplicity-->
        <xsl:variable name="subsetted" select="$models/key('ellookup',current()/role/vodml-ref)"/>
        <xsl:if test="name($subsetted)='attribute' and datatype/vodml-ref != $subsetted/datatype/vodml-ref"> <!-- only do this if types are different (subsetting can change just the semantic stuff)-->
            <xsl:variable name="javatype" select="vf:PythonType(datatype/vodml-ref)"/>
            <xsl:variable name="name" select="tokenize(role/vodml-ref/text(),'[.]')[last()]"/>
            <xsl:text>
    </xsl:text>
            <xsl:value-of select="concat($name,': ',$javatype)"/><xsl:text>
    """</xsl:text>
    * Attribute <xsl:value-of select="name"/> : subsetted
    *
            <xsl:apply-templates select="$subsetted" mode="desc"/>.
    """
        </xsl:if>
    </xsl:template>


    <xsl:template match="constraint[ends-with(@xsi:type,':SubsettedRole')]" mode="getset">

      <xsl:variable name="name" select="tokenize(role/vodml-ref/text(),'[.]')[last()]"/>
      <xsl:call-template name="doGetSet">
          <xsl:with-param name="name" select="$name"/>
          <xsl:with-param name="mult" select="$models/key('ellookup',current()/role/vodml-ref)/multiplicity"/>
      </xsl:call-template>

  </xsl:template>


  <xsl:template match="(attribute|composition[multiplicity/maxOccurs = 1])" mode="getset">
    <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
<!--      <xsl:message>attribute <xsl:value-of select="concat($vodml-ref,' from ', parent::*/name,' ', parent::*/@abstract, ' ', vf:isSubSetted($vodml-ref) )" /></xsl:message>-->
      <xsl:if test="not(parent::*/@abstract and vf:isSubSetted($vodml-ref))">
          <xsl:call-template name="doGetSet"/>
       </xsl:if>

   </xsl:template>

    <xsl:template name="doGetSet">
        <xsl:param name="name" select="name"/>
        <xsl:param name="type" select="vf:PythonType(datatype/vodml-ref)"/>
        <xsl:param name="mult" select="multiplicity"/>

        <xsl:variable name="upName">
            <xsl:call-template name="upperFirst">
                <xsl:with-param name="val" select="$name"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="fulltype">
            <xsl:choose>
                <xsl:when test="xsd:int($mult/maxOccurs) =-1"><xsl:value-of select="concat('java.util.List',$lt,$type,$gt)"/></xsl:when><!--TODO think about arrays -->
                <xsl:when test="xsd:int($mult/maxOccurs)  gt 1"><xsl:value-of select="concat($type,'[]')"/></xsl:when>
                <xsl:otherwise><xsl:value-of select="$type"/></xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        /**
        * Returns <xsl:value-of select="$name"/> Attribute
        * @return <xsl:value-of select="$name"/> Attribute
        */
        <xsl:if test="$mult/maxOccurs != 1">@SuppressWarnings("unchecked")</xsl:if><!--the cast should be ok even for the list-->
        public <xsl:value-of select="$fulltype"/>&bl;get<xsl:value-of select="$upName"/>() {
        return (<xsl:value-of select="$fulltype"/>)this.<xsl:value-of select="$name"/>;
        }
        <!-- cannot need to rely on most generic set if list of subsetted type, because of type erasure - IMPL might be able to do something clever with type argument on the base class, but gets tricky if there is more than one level of subclassing -->
        <xsl:if test="not(parent::*/extends and current()[ends-with(@xsi:type,':SubsettedRole')] and $mult/maxOccurs != 1)">
        /**
        * Defines <xsl:value-of select="$name"/> Attribute
        * @param p<xsl:value-of select="$upName"/> value to set
        */
        public void set<xsl:value-of select="$upName"/>(final <xsl:value-of select="$fulltype"/> p<xsl:value-of select="$upName"/>) {
        this.<xsl:value-of select="$name"/> = p<xsl:value-of select="$upName"/>;
        }
        </xsl:if>

        public <xsl:value-of select="vf:PythonType(vf:asvodmlref(parent::*))"/>&bl;with<xsl:value-of select="$upName"/>(final <xsl:value-of select="$fulltype"/> p<xsl:value-of select="$upName"/>) {
        this.<xsl:value-of select="$name"/> = p<xsl:value-of select="$upName"/>;
        return this;
        }

    </xsl:template>

  <xsl:template match="attribute" mode="setProperty">
    <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
      set<xsl:value-of select="$name"/>((<xsl:value-of select="$type"/><xsl:if test="contains(multiplicity,'*')">[]</xsl:if>)pValue);
      return true;
    }
  </xsl:template>

  <xsl:template match="attribute" mode="setStringProperty">
    <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
    <xsl:variable name="element" as="element()" select="vf:Element4vodml-ref(datatype/vodml-ref)"/>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:if test="$element/name() = 'enumeration' or $element/name() = 'primitiveType'">
    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
     <xsl:choose>
       <xsl:when test="$element/name() = 'enumeration'">
             set<xsl:value-of select="$name"/>(<xsl:value-of select="$type"/>.fromValue(pValue));
       </xsl:when>
       <xsl:otherwise>
      set<xsl:value-of select="$name"/>(new <xsl:value-of select="$type"/>(pValue));
       </xsl:otherwise>
     </xsl:choose>
      return true;
    }
    </xsl:if>
  </xsl:template>


    <xsl:template match="composition[multiplicity/maxOccurs != 1]" mode="declare">
        <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
        <xsl:call-template name="vodmlAnnotation"/><xsl:text>
    </xsl:text>

        <xsl:choose>
            <xsl:when test="vf:isSubSetted(vf:asvodmlref(.))">
                <xsl:value-of select="concat(name, ': list[',$type,']')"/> # IMPL is subsetted
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat(name, ': list[',$type,']')"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>
    """
    *
    * Composition </xsl:text><xsl:value-of select="name"/> : ( Multiplicity : <xsl:apply-templates select="multiplicity" mode="tostring"/>)
    <xsl:apply-templates select="." mode="desc"/>
    *
    """

    </xsl:template>

    <xsl:template match="composition[multiplicity/maxOccurs = 1]" mode="declare">
        <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
        <xsl:call-template name="vodmlAnnotation"/>
        <xsl:value-of select="concat(name,': ',$type)"/>
        """
        * Composition <xsl:value-of select="name"/> : ( Multiplicity : <xsl:apply-templates select="multiplicity" mode="tostring"/>)
        * <xsl:apply-templates select="." mode="desc" />
        """

    </xsl:template>




    <!-- define methods for getting/setting and adding to composition -->
  <xsl:template match="composition[multiplicity/maxOccurs != 1]" mode="getset">
    <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="datatype" select="substring-after(datatype/vodml-ref,':')"/>
    
    /**
    * Returns <xsl:value-of select="name"/> composition
    * @return <xsl:value-of select="name"/> composition
    */
      <xsl:choose>
      <xsl:when test="vf:isSubSetted(vf:asvodmlref(.))">
      public List&lt;? extends <xsl:value-of select="$type"/>&gt;&bl;get<xsl:value-of select="$name"/>() { // is subsetted
      </xsl:when>
      <xsl:otherwise>
      public List&lt;<xsl:value-of select="$type"/>&gt;&bl;get<xsl:value-of select="$name"/>() {
      </xsl:otherwise>
      </xsl:choose>
    return this.<xsl:value-of select="name"/>;
    }
    /**
    * Defines <xsl:value-of select="name"/> composition
    * @param p<xsl:value-of select="$name"/> composition to set
    */
    <xsl:choose>
        <xsl:when test="vf:isSubSetted(vf:asvodmlref(.))">
    public void set<xsl:value-of select="$name"/>(final List&lt;? extends <xsl:value-of select="$type"/>&gt; p<xsl:value-of select="$name"/>) {
        </xsl:when>
        <xsl:otherwise>
    public void set<xsl:value-of select="$name"/>(final List&lt;<xsl:value-of select="$type"/>&gt; p<xsl:value-of select="$name"/>) {
        </xsl:otherwise>
    </xsl:choose>
    this.<xsl:value-of select="name"/> = p<xsl:value-of select="$name"/>;
    }
    <xsl:if test="not(vf:isSubSetted(vf:asvodmlref(.)))">
    /**
    * Add a <xsl:value-of select="$type"/> to the composition
    * @param p&bl;<xsl:value-of select="$type"/> to add
    */
    public void add<xsl:value-of select="$name"/>(final <xsl:value-of select="$type"/> p) {
      if(this.<xsl:value-of select="name"/> == null) {
        this.<xsl:value-of select="name"/> = new ArrayList&lt;&gt;();
      }
      this.<xsl:value-of select="name"/>.add(p);
    }
    </xsl:if>
  </xsl:template>

    <xsl:template match="objectType" mode="jpawalker">

            @Override
            public void walkCollections() {
        <xsl:apply-templates select="composition|reference" mode="jpawalker"/>
               <xsl:if test="extends">
                   super.walkCollections();
               </xsl:if>
            }
    </xsl:template>

    <xsl:template match="composition[multiplicity/maxOccurs != 1]" mode="jpawalker">
        for( <xsl:value-of select="vf:FullJavaType(datatype/vodml-ref, true())"/> c : <xsl:value-of select="name"/> ) {
           c.walkCollections();
        }

    </xsl:template>
    <xsl:template match="composition|reference" mode="jpawalker">
        if( <xsl:value-of select="name"/> != null ) <xsl:value-of select="name"/>.walkCollections();
    </xsl:template>
    <xsl:template match="dataType" mode="jpawalker">
        <!-- do nothing for datatypes -->
    </xsl:template>

    <xsl:template match="composition[multiplicity/maxOccurs != 1]" mode="add2composition">
    <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
      add<xsl:value-of select="$name"/>((<xsl:value-of select="$type"/>)object);
      return true;
    }
  </xsl:template>



  <xsl:template match="reference" mode="declare"><!-- IMPL could be the same as attribute - actually more usefully so if reference allowed to have >1 multiplicity -->
    <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
    <xsl:call-template name="vodmlAnnotation"/><xsl:text>
    </xsl:text>
      <xsl:value-of select="concat(name, ': ', $type)"/><xsl:text>
    """
    * ReferenceObject </xsl:text><xsl:value-of select="name"/> :
    * <xsl:apply-templates select="." mode="desc" />
    * ( Multiplicity : <xsl:apply-templates select="multiplicity" mode="tostring"/>) """
  </xsl:template>




  <xsl:template match="reference" mode="getset">
    <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    /**
    * Returns <xsl:value-of select="name"/> Reference<br/>
    * @return <xsl:value-of select="name"/> Reference
    */
    public <xsl:value-of select="$type"/>&bl;get<xsl:value-of select="$name"/>() {
        return this.<xsl:value-of select="name"/>;
    }
    /**
    * Defines <xsl:value-of select="name"/> Reference
    * @param p<xsl:value-of select="$name"/> reference to set
    */
    public void set<xsl:value-of select="$name"/>(final <xsl:value-of select="$type"/> p<xsl:value-of select="$name"/>) {
        this.<xsl:value-of select="name"/> = p<xsl:value-of select="$name"/>;
    }
  </xsl:template>




  <xsl:template match="reference" mode="setProperty">
    <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>

    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
      if(pValue instanceof ReferenceObject)
        set<xsl:value-of select="$name"/>((ReferenceObject)pValue);
      else 
        set<xsl:value-of select="$name"/>((<xsl:value-of select="$type"/>)pValue);
      return true;
    }
  </xsl:template>

    <xsl:template match="literal" >
    <xsl:variable name="up">
      <xsl:call-template name="constant">
        <xsl:with-param name="text" select="name"/>
      </xsl:call-template>
    </xsl:variable>
        <xsl:text>
    </xsl:text><xsl:value-of select="$up"/> = <xsl:value-of select="count(preceding-sibling::literal)"/>
    """
    * Value <xsl:value-of select="name"/> :
    *
    * <xsl:apply-templates select="." mode="desc" />
    """
  </xsl:template>


  <xsl:template match="attribute|reference|composition" mode="getProperty">
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
      return get<xsl:value-of select="$name"/>();
    }
  </xsl:template>




  <xsl:template match="*" mode="desc">
    <xsl:choose>
      <xsl:when test="count(description) > 0 and normalize-space(description) != 'TODO : Missing description : please, update your UML model asap.'">
          <xsl:value-of select="description" disable-output-escaping="yes"/>
          <xsl:if test="not(ends-with(normalize-space(description/text()), '.'))">
              <xsl:value-of select="'.'"/>
          </xsl:if>
      </xsl:when>
      <xsl:otherwise>
<!--       <xsl:message >TODO : <xsl:value-of select="name"/> Missing description : please, update your VO-DML model asap.</xsl:message> -->
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>  




  <!-- specific documents --> 

 

  <!-- package.html -->
  <xsl:template match="vo-dml:model|package" mode="packageDesc">
    <xsl:param name="dir"/>
      <xsl:param name="path"/>

      <xsl:variable name="file" select="concat($output_root,'/',$dir,'/__init__.py')"/>
      <!-- open file for this class -->
      <xsl:message >Writing package info file <xsl:value-of select="$file"/></xsl:message>
      <xsl:result-document href="{$file}" >

      </xsl:result-document>

  </xsl:template>


  <xsl:template name="TypeImport">
    <xsl:param name="vodml-ref"/>
 <!--
        <xsl:message>Looking for vodml-ref <xsl:value-of select="$vodml-ref"/></xsl:message>
 -->    
    <xsl:variable name="vodml-id" select="substring-after($vodml-ref,':')"/>
    <xsl:variable name="mappedtype" select="vf:findmapping($vodml-ref,'java')" />

<!--     <xsl:message>TypeImprt: mappedtype =  "<xsl:value-of select="$mappedtype"/>"</xsl:message> -->
   <xsl:choose>
      <xsl:when test="$mappedtype != ''">
<!--          <xsl:message>TypeImprt: found mapping for <xsl:value-of select="$vodml-ref"/>, no import necessary</xsl:message> -->
      </xsl:when>
      <xsl:otherwise>
<!--          <xsl:message>TypeImprt: building import for <xsl:value-of select="$vodml-ref" /></xsl:message> -->
         <xsl:variable name="themodel" as="element()">
            <xsl:call-template name="getmodel">
               <xsl:with-param name="vodml-ref" select="$vodml-ref" />
            </xsl:call-template>
         </xsl:variable>
<!--          <xsl:message>TypeImprt: looking for <xsl:value-of select="$vodml-ref" /> in model = <xsl:value-of select="$themodel/name" /></xsl:message> -->
         <xsl:variable name="type" as="element()" select="$themodel//*[vodml-id = $vodml-id]" />
         <xsl:variable name="path">
            <xsl:call-template name="package-path">
               <xsl:with-param name="model" select="$themodel" />
               <xsl:with-param name="packageid">
                  <xsl:value-of select="$type/../vodml-id" />
               </xsl:with-param>
               <xsl:with-param name="delimiter">.</xsl:with-param>
            </xsl:call-template>
         </xsl:variable>
         <xsl:variable name="root" select="$mapping/map:mappedModels/model[name=$themodel/name]/java-package" />
 import <xsl:value-of select="$root" /><xsl:if test="$path !=''">.</xsl:if><xsl:value-of select="$path" />.<xsl:value-of select="$type/name" />;
      </xsl:otherwise>
   </xsl:choose>
  </xsl:template> 
  
  <xsl:template match="objectType|dataType|enumeration|primitiveType" mode="path">
    <xsl:variable name="modelname" select="./ancestor::vo-dml:model/name"/>
    
    <xsl:message >Looking for path for <xsl:value-of select="vodml-id"/> in model <xsl:value-of select="$modelname"/>
    </xsl:message>

     <xsl:variable name="path" >
      <xsl:call-template name="package-path">
        <xsl:with-param name="model" select="./ancestor::vo-dml:model"/>
        <xsl:with-param name="packageid"><xsl:value-of select="./../vodml-id"/></xsl:with-param>
        <xsl:with-param name="delimiter">.</xsl:with-param>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="root" select="$mapping/map:mappedModels/model[name=$modelname]/java-package"/>
    <xsl:value-of select="$root"/><xsl:if test="$path !=''">.</xsl:if><xsl:value-of select="$path"/>.<xsl:value-of select="name"/>
  </xsl:template>
  
  



 

  <!-- find a java package path towards the type identified with the name -->
  <xsl:template name="fullpath">
    <xsl:param name="vodml-ref"/>
     <!-- <xsl:message >Finding full path for <xsl:value-of select="$vodml-ref"/></xsl:message> -->
    
    <xsl:variable name="themodel" as="element()">
        <xsl:call-template name="getmodel"><xsl:with-param name="vodml-ref" select="$vodml-ref"/></xsl:call-template>
    </xsl:variable>

    <xsl:variable name="root" select="$mapping/map:mappedModels/model[name=$themodel/name]/java-package"/>

    <xsl:variable name="vodmlid" select="substring-after($vodml-ref,':' )"/>    
    <xsl:variable name="path">
    <xsl:for-each select="$themodel//*[vodml-id=$vodmlid]/ancestor-or-self::*[name() != 'vo-dml:model']">
       <xsl:value-of select="./name"/>
       <xsl:if test="position() != last()">
       <xsl:text>.</xsl:text>
       </xsl:if>
    </xsl:for-each>
    </xsl:variable>
    <xsl:value-of select="concat($root,'.',$path)"/>

  </xsl:template>
 <xsl:template name="vodmlAnnotation">
     <!-- nothing for now -->
 </xsl:template>


</xsl:stylesheet>
