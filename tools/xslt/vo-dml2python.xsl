<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE stylesheet [
<!ENTITY cr "<xsl:text>
</xsl:text>">
<!ENTITY bl "<xsl:text> </xsl:text>">
]>

<xsl:stylesheet version="3.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:vo-dml="http://www.ivoa.net/xml/VODML/v1"
                xmlns:vf="http://www.ivoa.net/xml/VODML/functions"
                xmlns:exsl="http://exslt.org/common"
                xmlns:bnd="http://www.ivoa.net/xml/vodml-binding/v0.9.1"
                xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                extension-element-prefixes="exsl"
                exclude-result-prefixes="bnd"
                >
<!-- 
  This XSLT script transforms a data model in VO-DML/XML representation to 
  Python dataclasses

  N.B this script is fragile to indentation (because of python - there should probably be a better way to get indentation to work)

  needs Python 3.10+
  
  Paul Harrison (JBO)
-->


  <xsl:output method="xml" encoding="UTF-8" indent="yes" />
  <xsl:output name="python" method="text" encoding="UTF-8" omit-xml-declaration="yes"/>

  <xsl:strip-space elements="*" />


  <xsl:param name="lastModified"/>
  <xsl:param name="lastModifiedText"/>
  <xsl:param name="output_root" />
  <xsl:param name="vo-dml_package" select="'org.ivoa.vodml.model'"/>
  <xsl:param name="binding"/>
    <xsl:param name="isMain"/>
   <xsl:include href="binding_setup.xsl" />


    <xsl:variable name="root_package" select="$mapping/bnd:mappedModels/model[name=$themodelname]/python-package"/>
    <xsl:variable name="root_package_dir" select="replace($root_package,'[.]','/')"/> <!-- not windows friendly! -->
    
   


  <!-- main pattern : processes for root node model -->
    <xsl:template match="/">
  <xsl:message >Generating Python - considering models <xsl:value-of select="string-join($models/vo-dml:model/name,' and ')" /></xsl:message>
  <xsl:apply-templates mode="intro"/>
 </xsl:template>

  <!-- model pattern : generates gen-log and processes nodes package and generates the ModelVersion class and persistence.xml -->
  <xsl:template match="vo-dml:model" mode="intro">
    <xsl:message>
-------------------------------------------------------------------------------------------------------
-- Generating Python code for model <xsl:value-of select="name"/> [<xsl:value-of select="title"/>].
-- last modification date of the model <xsl:value-of select="lastModified"/>
-------------------------------------------------------------------------------------------------------
    </xsl:message>


      <xsl:if test="not($mapping/bnd:mappedModels/model[name=$themodelname])">
          <xsl:message terminate="yes">
              There is no binding for model <xsl:value-of select="$themodelname"/>
          </xsl:message>
      </xsl:if>

      <!-- write init in the package path elements - seems quite difficult to do! -->
      <xsl:variable name="path" select="subsequence(reverse(tokenize($root_package, '\.')),2)" />
      <xsl:message><xsl:value-of select="$path"/></xsl:message>
      <xsl:for-each select="1 to count($path)">
          <xsl:variable name="subpath" select="concat(string-join(reverse(subsequence($path, current())),'/'),'/__init__.py')" />
          <xsl:result-document href="{$subpath}" format="python" omit-xml-declaration="yes">
          <xsl:value-of select="concat('# Generated by gradle vodml tools ',current-dateTime())"/>
          </xsl:result-document>
      </xsl:for-each>
       <!--
          <xsl:message>root_package = <xsl:value-of select="$root_package"/></xsl:message>
          <xsl:message>root_package_dir = <xsl:value-of select="$root_package_dir"/></xsl:message>
       -->


<!--       <xsl:apply-templates select="." mode="modelClass">-->
<!--          <xsl:with-param name="root_package" select="$root_package"/>-->
<!--          <xsl:with-param name="root_package_dir" select="$root_package_dir"/>-->
<!--      </xsl:apply-templates>-->
      <xsl:apply-templates select="." mode="packageDesc"/>
      <xsl:apply-templates select="." mode="content"/>
  </xsl:template>




  <xsl:template match="vo-dml:model|package" mode="content">

      <xsl:variable name="file" select="concat($root_package_dir, '/',string-join(./ancestor-or-self::*/name,'_') , '.py')"/>
      <xsl:variable name="package-vodml-ref" select="concat(./ancestor-or-self::vo-dml:model/name,':',string-join(./ancestor-or-self::package/name,'.'))"/>
      <xsl:message>package = <xsl:value-of select="concat(name,' ',$file,' ',$package-vodml-ref)"></xsl:value-of></xsl:message>
      <xsl:result-document href="{$file}" format="python">
          <xsl:value-of select="concat('# Generated by gradle vodml tools ',current-dateTime())"/>

<xsl:text>
from __future__ import annotations
import dataclasses
from typing import Optional, List, Tuple, Any
import enum
import sqlalchemy
import sqlalchemy.orm
from vodml_runtime.registry import mapper_registry


</xsl:text>
          <xsl:for-each select="distinct-values((*/((attribute|reference|composition|constraint[contains(@xsi:type,'SubsettedRole')])/datatype/vodml-ref)|*/extends/vodml-ref))">
              <xsl:if test="not(vf:isPythonBuiltin(.))">
                  <xsl:variable name="typepackage" select="concat(substring-before(.,':'),':',string-join(tokenize(substring-after(.,':'),'\.')[position() != last()],'.'))"/>
                      <xsl:if test="(vf:hasMapping(.,'python') or $typepackage != $package-vodml-ref)   ">
                          <xsl:variable name="fulltype" select="vf:FullPythonType(.,true())"/>
from <xsl:value-of select="vf:PythonModule(.)"/> import <xsl:value-of select="tokenize($fulltype, '\.')[last()]"/>
                      </xsl:if>
              </xsl:if>
          </xsl:for-each>
          <xsl:apply-templates select="primitiveType" mode="file"/>
          <xsl:apply-templates select="enumeration" mode="file"/>
          <xsl:apply-templates select="objectType|dataType" mode="file">
              <xsl:sort select="vf:numberSupertypes(vf:asvodmlref(current()))" data-type="number"/>
          </xsl:apply-templates>
      </xsl:result-document>
      <xsl:apply-templates select="package" mode="content"/>

  </xsl:template>


  <xsl:template match="objectType|dataType|enumeration|primitiveType" mode="file">
    <xsl:variable name="vodml-id" select="vodml-id" />
    <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
    <xsl:variable name="mappedtype" select="vf:findmapping($vodml-ref,'python')"/>
    <xsl:choose>
    <xsl:when test="not($mappedtype) or $mappedtype = ''" >
      <xsl:message >Writing code for <xsl:value-of select="name"/> base=<xsl:value-of select="vf:baseTypes($vodml-ref)/name"/> haschildren=<xsl:value-of select="vf:hasSubTypes($vodml-ref)"/> contained=<xsl:value-of select="vf:isContained($vodml-ref)"/> referredto=<xsl:value-of select="vf:referredTo($vodml-ref)"/> </xsl:message>
      <xsl:apply-templates select="." mode="content"/>
    </xsl:when>
      <xsl:otherwise>
       <xsl:message>1) Mapped type for <xsl:value-of select="$vodml-ref"/> = '<xsl:value-of select="$mappedtype"/>'</xsl:message>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>



  <xsl:template match="attribute|composition|reference" mode="paramDecl">
      <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
      <xsl:choose>
          <xsl:when test="name()='composition' and multiplicity/maxOccurs != 1" >
              <xsl:choose>
                  <xsl:when test="vf:isSubSetted(vf:asvodmlref(.))">
                      <xsl:value-of select="concat(name,' : List[',$type, ']')"/> = field(default_factory=list, kw_only=True,
                      metadata={
                      "type": "Element"
                      })
                  </xsl:when>
                  <xsl:otherwise>
                      <xsl:value-of select="concat(name,' : List[',$type, ']')"/> = dataclasses.field(default_factory=list, kw_only=True,
                      metadata={
                          "type": "Element"
                      })
                  </xsl:otherwise>
              </xsl:choose>

          </xsl:when>
          <xsl:otherwise>
              <xsl:choose>
                  <xsl:when test="xsd:int(multiplicity/maxOccurs) gt 1"> <!-- IMPL arrays are just lists for now -->
                      <xsl:value-of select="concat(name,' : List[',$type, ']')"/> = dataclasses.field(default_factory=list, kw_only=True,
                      metadata={
                      "type": "Element"
                      })
                  </xsl:when>
                  <xsl:when test="multiplicity/maxOccurs = -1">
                      <xsl:value-of select="concat(name,' : List[',$type, ']')"/> = dataclasses.field(default_factory=list, kw_only=True,
                      metadata={
                      "type": "Element"
                      })
                  </xsl:when>
                  <xsl:otherwise>
                      <xsl:value-of select="concat(name, ': ',$type)" /> = dataclasses.field(kw_only=True,
                         metadata = {
                        <xsl:if test="vf:PythonFormat(datatype/vodml-ref)">
                          "format":"<xsl:value-of select="vf:PythonFormat(datatype/vodml-ref)"/>"
                        </xsl:if>

                      })
                  </xsl:otherwise>
              </xsl:choose>

          </xsl:otherwise>
      </xsl:choose>

  </xsl:template>

    <!-- template class creates a java class (JPA compliant) for UML object & data types -->
  <xsl:template match="objectType" mode="content">
    <xsl:variable name="vodml-ref" select="vf:asvodmlref(current())"/>
    <xsl:text>
</xsl:text>
    <xsl:call-template name="vodmlAnnotation"/>

@mapper_registry.mapped
@dataclasses.dataclass<xsl:if test="@abstract"><xsl:text>(init=False)</xsl:text></xsl:if>
class <xsl:value-of select="name"/>
      <xsl:if test="extends"><xsl:value-of select="concat('(',vf:PythonType(extends/vodml-ref),')')"/></xsl:if>:
    """
    * <xsl:apply-templates select="." mode="desc" />
    *
    * <xsl:value-of select="name()"/>: &bl;<xsl:value-of select="name" />
    *
    * <xsl:value-of select="$vodmlauthor"/>
    """
    <xsl:apply-templates select="." mode="table"/>
    <xsl:if test="vf:hasSubTypes($vodml-ref) or extends">
    dtype: str = dataclasses.field(init=False,
                 metadata={
                      "type": "Ignore",
                      "sa": __table__.c.dtype
                    }
                )
    __mapper_args__ = {
        "polymorphic_identity": "<xsl:value-of select="$vodml-ref"/>",
        <xsl:if test="not(extends)">
        "polymorphic_on": "dtype",
        </xsl:if>
    }
    </xsl:if>
      <xsl:if test="not(attribute/constraint[ends-with(@xsi:type,':NaturalKey')])" >
    id: int = dataclasses.field(init=False, metadata={
                  "sa": __table__.c.id
                  })
     </xsl:if>

      <xsl:apply-templates select="(attribute|composition|reference)[multiplicity/minOccurs=1 and multiplicity/maxOccurs=1]" mode="declare" /> <!-- attempt to get required before optional -
                        does not work for class hierarchies, see https://stackoverflow.com/questions/51575931/class-inheritance-in-python-3-7-dataclasses-->
      <xsl:apply-templates select="(attribute|composition|reference)[not(multiplicity/minOccurs=1 and multiplicity/maxOccurs=1)]" mode="declare" />
      <xsl:apply-templates select="constraint[ends-with(@xsi:type,':SubsettedRole')]" mode="declare" />

  </xsl:template>

    <xsl:template match="dataType" mode="content">
        <xsl:variable name="vodml-ref" select="vf:asvodmlref(current())"/>
        <xsl:text>
</xsl:text>
        <xsl:call-template name="vodmlAnnotation"/>
@dataclasses.dataclass<xsl:if test="@abstract"><xsl:text>(init=False)</xsl:text></xsl:if>
class <xsl:value-of select="name"/>
    <xsl:if test="extends"><xsl:value-of select="concat('(',vf:PythonType(extends/vodml-ref),')')"/></xsl:if>:
    """
    * <xsl:apply-templates select="." mode="desc" />
    *
    * <xsl:value-of select="name()"/>: &bl;<xsl:value-of select="name" />
    *
    * <xsl:value-of select="$vodmlauthor"/>
    """
        <!--
              /** serial uid = last modification date of the UML model */
              private static final long serialVersionUID = LAST_MODIFICATION_DATE;
         -->
        <xsl:apply-templates select="(attribute|reference)[multiplicity/minOccurs=1 and multiplicity/maxOccurs=1]" mode="declare" /> <!-- attempt to get required before optional -
                        does not work for class hierarchies, see https://stackoverflow.com/questions/51575931/class-inheritance-in-python-3-7-dataclasses-->
        <xsl:apply-templates select="(attribute|reference)[not(multiplicity/minOccurs=1 and multiplicity/maxOccurs=1)]" mode="declare" />
        <xsl:apply-templates select="constraint[ends-with(@xsi:type,':SubsettedRole')]" mode="declare" />
        <xsl:variable name="memberinfo">
            <xsl:element name="memberInfo">
                <xsl:copy-of select="vf:PythonDataTypeMemberInfo($vodml-ref)"/>
            </xsl:element>
        </xsl:variable>
        <xsl:if test="not(@abstract)"><!-- TODO - do not need if DataClass does not contain DataClasses -->
    @classmethod
    def _generate(cls,
        <xsl:message select="$memberinfo"/>
        <xsl:variable name="args" as="xsd:string*">
            <xsl:apply-templates select="$memberinfo//member[count(*) = 0]" mode="datt"/>
        </xsl:variable>
        <xsl:value-of select="string-join($args,', ')"/>
        ) -&gt; <xsl:value-of select="name"/>:
        """generate a <xsl:value-of select="name"/> from a row"""
        return <xsl:value-of select="name"/>(
            <xsl:apply-templates select="$memberinfo/*" mode="dcall"/>
          )

    def __composite_values__(self) -> Tuple[Any, ...]:
        """generate a row from a  <xsl:value-of select="name"/>"""
            <xsl:variable name="tuple" as="xsd:string*">
                <xsl:apply-templates select="$memberinfo/*/member" mode="tuple"/>
            </xsl:variable>
        return  <xsl:value-of select="string-join($tuple, ' + ')"/>
        </xsl:if>
    </xsl:template>
    <xsl:template match="member[not(*)]" mode="tuple">
        <xsl:value-of select="concat('(self.',@name,',)')"/>
    </xsl:template>
    <xsl:template match="member[*]" mode="tuple">
        <xsl:value-of select="concat('dataclasses.astuple(self.',@name,')')"/>
    </xsl:template>
    <xsl:template match="member" mode="datt"> <!-- processes the output of PythonDataTypeMemberInfo -->
        <xsl:value-of select="concat(string-join(ancestor-or-self::*/@name,'_'),': ', @ptype)"/>
    </xsl:template>
    <xsl:template match="member[count(*)> 0]" mode="dcall"> <!-- processes the output of PythonDataTypeMemberInfo -->
            <xsl:value-of select="concat(@ptype,'(')"/>
                <xsl:apply-templates select="*" mode="dcall"/>
                <xsl:value-of select="')'"/>
                <xsl:if test="count(following-sibling::*) > 0">, </xsl:if>
    </xsl:template>
    <xsl:template match="member" mode="dcall"> <!-- processes the output of PythonDataTypeMemberInfo -->
        <xsl:value-of select="string-join(ancestor-or-self::*/@name,'_')"/>
        <xsl:if test="count(following-sibling::* )>0">, </xsl:if>
    </xsl:template>


    <xsl:template match="member[count(*) = 0]" mode="dtuple"> <!-- processes the output of PythonDataTypeMemberInfo -->
        <xsl:value-of select="string-join(ancestor-or-self::*/@name,'_')"/>
        <xsl:if test="count(following-sibling::* )>0">, </xsl:if>
    </xsl:template>

    <xsl:template name="memberinfo">
        <xsl:variable name="vodml-ref" select="vf:asvodmlref(current())"/>
        <xsl:element name="memberInfo">
            <xsl:for-each select="constraint[ends-with(@xsi:type,':SubsettedRole') and vf:isSubSetted(./role/vodml-ref)]">
                <xsl:variable name="type" select="vf:el4vodmlref(current()/datatype/vodml-ref)"/>
                <xsl:variable name="role" select="vf:el4vodmlref(current()/role/vodml-ref)"/>

                <xsl:element name="member">
                    <xsl:attribute name="name" select="$role/name"/>
                    <xsl:choose>
                        <xsl:when test="$type/name() = 'dataType'">
                            <xsl:copy-of select="vf:PythonDataTypeMemberInfo(datatype/vodml-ref)"/>
                        </xsl:when>
                        <xsl:when test="$type/name() = 'enumeration'">
                            <xsl:attribute name="altype" select="concat('sqlalchemy.Enum(',$type/name,')')"/>
                        </xsl:when>
                    </xsl:choose>
                </xsl:element>
            </xsl:for-each>
            <xsl:for-each select="attribute[not(vf:isSubSetted(vf:asvodmlref(.)))]"><!-- |composition|reference -->
                <xsl:element name="member">
                    <xsl:variable name="type" select="vf:el4vodmlref(current()/datatype/vodml-ref)"/>

                    <xsl:attribute name="name" select="name"/>
                    <xsl:attribute name="vtype" select="name()"/>
                    <xsl:variable name="vodml-ref" select="vf:asvodmlref(current())"/>
                    <xsl:attribute name="vodml-ref" select="$vodml-ref"/>
                    <xsl:attribute name="altype" select="vf:PythonAlchemyType(datatype/vodml-ref)"/>
                    <xsl:if test="constraint[ends-with(@xsi:type,':NaturalKey')]">
                        <xsl:attribute name="isKey" select="constraint[ends-with(@xsi:type,':NaturalKey')]"/>
                    </xsl:if>
                    <xsl:choose>
                        <xsl:when test="name()='attribute'">
                            <xsl:choose>
                                <xsl:when test="$type/name() = 'dataType'">
                                    <xsl:copy-of select="vf:PythonDataTypeMemberInfo(datatype/vodml-ref)"/>
                                </xsl:when>
                                <xsl:when test="$type/name() = 'enumeration'">
                                    <xsl:attribute name="altype" select="concat('sqlalchemy.Enum(',$type/name,')')"/>
                                </xsl:when>
                            </xsl:choose>
                        </xsl:when>
                        <xsl:otherwise></xsl:otherwise>
                    </xsl:choose>
                </xsl:element>
            </xsl:for-each>
            <xsl:if test="vf:isContained($vodml-ref)">
                <xsl:for-each select="vf:containingTypes($vodml-ref)"><!--TODO need to deal with natural keys -->
                    <xsl:element name="member">
                        <xsl:attribute name="name" select="concat(upper-case(current()/name),'_ID')"/>
                        <xsl:attribute name="altype" select="'sqlalchemy.Integer'"/>
                        <xsl:attribute name="fk" select="concat(current()/name,'.id')"/>
                    </xsl:element>
                </xsl:for-each>
            </xsl:if>
        </xsl:element>

    </xsl:template>
    <xsl:template match="objectType" mode="table">
        <xsl:variable name="vodml-ref" select="vf:asvodmlref(current())"/>

        <xsl:variable name="memberInfo" as="element()">
           <xsl:call-template name="memberinfo"/>
       </xsl:variable>
        <xsl:message>ml=<xsl:copy-of select="$memberInfo"/></xsl:message>
    __table__ = sqlalchemy.Table("<xsl:value-of select="name"/>",mapper_registry.metadata,
        <xsl:if test="not(attribute/constraint[ends-with(@xsi:type,':NaturalKey')])">
        sqlalchemy.Column("id",sqlalchemy.Integer, sqlalchemy.Identity(), primary_key=True),
        </xsl:if>
        <xsl:if test="vf:hasSubTypes($vodml-ref) or extends">
        sqlalchemy.Column("dtype",sqlalchemy.String),

        </xsl:if>
        <xsl:if test="extends">
            <xsl:variable name="toptype" select="vf:PythonType(extends/vodml-ref)"/>
        sqlalchemy.Column("<xsl:value-of select="concat($toptype,'_ID')"/>", <!--TODO deal with types of natural keys -->
            sqlalchemy.Integer, sqlalchemy.ForeignKey("<xsl:value-of select="concat($toptype,'.id')"/>")),
        </xsl:if>
        <xsl:apply-templates select="$memberInfo//member[not(*)]" mode="table"/>
        )
    __sa_dataclass_metadata_key__ = "sa"
    </xsl:template>
    <xsl:template match="member" mode="table">
        <xsl:choose>
            <xsl:when test="@isKey">
        sqlalchemy.Column("<xsl:value-of select="concat(string-join(ancestor-or-self::*/@name,'_'),$dq,',',@altype,', primary_key=True)')"/>
            </xsl:when>
            <xsl:when test="@fk" >
        sqlalchemy.Column("<xsl:value-of select="concat(string-join(ancestor-or-self::*/@name,'_'),$dq,',',@altype,', sqlalchemy.ForeignKey(',$dq,@fk,$dq,'))')"/>
            </xsl:when>
            <xsl:otherwise>
        sqlalchemy.Column("<xsl:value-of select="concat(string-join(ancestor-or-self::*/@name,'_'),$dq,',',@altype,')')"/>
            </xsl:otherwise>
        </xsl:choose>
        <xsl:if test="count(following::member)>0">, </xsl:if>
    </xsl:template>

    <xsl:template match="enumeration" mode="content">
      <xsl:text>


class </xsl:text><xsl:value-of select="concat(name,'(enum.Enum):')"/>
    """
    * <xsl:apply-templates select="." mode="desc" />
    *
    * Enumeration <xsl:value-of select="name"/> :
    *
    * <xsl:value-of select="$vodmlauthor"/>
    """
<xsl:apply-templates select="literal"  />
&cr;
   </xsl:template>

  <xsl:template match="primitiveType" mode="content">
    <xsl:param name="path"/>
    <xsl:variable name="valuetype">
      <xsl:choose>
        <xsl:when test="extends">
          <xsl:value-of select="vf:PythonType(extends/vodml-ref)"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:message>Primitive type <xsl:value-of select="name"/> is being represented as a String - in general it is probably best to specialize primitive types with the binding mechanism to get desired representation/behavious</xsl:message>
            <xsl:value-of select="'str'"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
      <xsl:call-template name="vodmlAnnotation"/><xsl:text>

@dataclasses.dataclass
class </xsl:text><xsl:value-of select="name"/>:
    """
    *  <xsl:apply-templates select="." mode="desc" />
    *  PrimitiveType <xsl:value-of select="name"/> :
    *
    *  <xsl:value-of select="$vodmlauthor"/>
    """

    value: <xsl:value-of select="$valuetype"/>


  </xsl:template>


    <xsl:template match="attribute" mode="declare">
        <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
        <xsl:variable name="vtype" select="vf:el4vodmlref(datatype/vodml-ref)"/>
        <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
        <xsl:if test="not(vf:isSubSetted($vodml-ref))">
            <xsl:text>
    </xsl:text>
            <xsl:call-template name="vodmlAnnotation"/>
            <xsl:choose>
                <xsl:when test="xsd:int(multiplicity/maxOccurs) gt 1">
                    <xsl:value-of select="concat(name, ': List[',$type,'] = dataclasses.field(default_factory=list, kw_only=True, metadata={',$dq,'type',$dq,': ',$dq,'Element',$dq,'})')"/> <!-- IMPL arrays are just lists for now -->
                </xsl:when>
                <xsl:when test="xsd:int(multiplicity/maxOccurs) lt 0">
                    <xsl:value-of select="concat(name, ': List[',$type,'] = dataclasses.field(default_factory=list, kw_only=True, metadata={',$dq,'type',$dq,': ',$dq,'Element',$dq,'})')"/>
                </xsl:when>
                <xsl:otherwise>
                    <xsl:variable name="kwstatus">
                        <xsl:value-of select="'True'"/>
<!--                        <xsl:choose>-->
<!--                            <xsl:when test="current()/parent::objectType">True</xsl:when>-->
<!--                            <xsl:otherwise>False</xsl:otherwise>-->
<!--                        </xsl:choose>-->
                    </xsl:variable>

                    <xsl:choose>
                        <xsl:when test="vf:isOptional(.)">
                            <xsl:value-of select="concat(name,': Optional[',$type,']')"/>= dataclasses.field(default=None,kw_only=<xsl:value-of select="$kwstatus"/>,
                        </xsl:when>
                       <xsl:otherwise>
                           <xsl:value-of select="concat(name,': ',$type)"/> = dataclasses.field(kw_only=<xsl:value-of select="$kwstatus"/>,
                       </xsl:otherwise>
                    </xsl:choose>
                           metadata={
                              <xsl:variable name="meta" as="xsd:string*">
                                  <xsl:if test="vf:PythonFormat(datatype/vodml-ref)">
                                      <xsl:sequence select="concat($dq,'format',$dq,': ',$dq,vf:PythonFormat(datatype/vodml-ref),$dq)"/>
                                  </xsl:if>

                                  <xsl:choose>
                                      <xsl:when test="parent::objectType and $vtype/name()=('primitiveType','enumeration')">
                                          <xsl:sequence select="concat($dq,'sa',$dq,': __table__.c.',current()/name)"/>
                                      </xsl:when>
                                      <xsl:when test="parent::dataType">
                                      <!-- do nothing -->
                                      </xsl:when>
                                      <xsl:otherwise>
                                          <xsl:variable name="atts" as="xsd:string*">
                                              <xsl:apply-templates select="vf:PythonDataTypeMemberInfo(datatype/vodml-ref)//member[not(*)]" mode="datt"/>
                                          </xsl:variable>
                                          <xsl:sequence select="concat($dq,'sa',$dq,': sqlalchemy.orm.composite(',vf:PythonType(datatype/vodml-ref),'._generate,',
                                          string-join(for $x in $atts return
                                          concat('__table__.c.',current()/name,'_',substring-before($x,':')),', '),')')"/>
                                      </xsl:otherwise>

                                  </xsl:choose>
                              </xsl:variable>
                              <xsl:value-of select="string-join($meta,',')"/>
                              }
                           )

                </xsl:otherwise>
            </xsl:choose>
    """
     Attribute <xsl:value-of select="name"/> : multiplicity <xsl:apply-templates select="multiplicity" mode="tostring"/><xsl:text>

        </xsl:text>
            <xsl:apply-templates select="." mode="desc"/>
    """
        </xsl:if>
    </xsl:template>


    <xsl:template match="constraint[ends-with(@xsi:type,':SubsettedRole')]" mode="declare">
        <!-- FIXME subsets can also be of compositions and references - worry about multiplicity-->
        <xsl:variable name="subsetted" select="$models/key('ellookup',current()/role/vodml-ref)"/>
        <xsl:if test="name($subsetted)='attribute' and datatype/vodml-ref != $subsetted/datatype/vodml-ref"> <!-- only do this if types are different (subsetting can change just the semantic stuff)-->
            <xsl:variable name="javatype" select="vf:PythonType(datatype/vodml-ref)"/>
            <xsl:variable name="name" select="tokenize(role/vodml-ref/text(),'[.]')[last()]"/>
            <xsl:text>
    </xsl:text>
            <xsl:value-of select="concat($name,': ',$javatype)"/>= dataclasses.field(kw_only=True,
                  metadata = {
                     <xsl:if test="vf:PythonFormat(datatype/vodml-ref)">
                         "format": "<xsl:value-of select="vf:PythonFormat(datatype/vodml-ref)"/>"
                     </xsl:if>
                }
                )
    """
    * Attribute <xsl:value-of select="name"/> : subsetted
    *
            <xsl:apply-templates select="$subsetted" mode="desc"/>.
    """
        </xsl:if>
    </xsl:template>


    <xsl:template match="composition[multiplicity/maxOccurs != 1]" mode="declare">
        <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
        <xsl:call-template name="vodmlAnnotation"/><xsl:text>

    </xsl:text>
        <xsl:choose>
            <xsl:when test="vf:isSubSetted(vf:asvodmlref(.))">
                <xsl:value-of select="concat(name, ': List[',$type,']=dataclasses.field(default_factory=list, kw_only=True, metadata={',$dq,'type',$dq,': ',$dq,'Element',$dq,'})')"/> # IMPL is subsetted
            </xsl:when>
            <xsl:otherwise>
                <xsl:value-of select="concat(name, ': List[',$type,']')"/> = dataclasses.field(default_factory=list, kw_only=True,
                metadata={
                "type": "Element"
                ,"sa": sqlalchemy.orm.relationship("<xsl:value-of select="$type"/>")
                })
            </xsl:otherwise>
        </xsl:choose>
        <xsl:text>
    """
    *
    * Composition </xsl:text><xsl:value-of select="name"/> : ( Multiplicity : <xsl:apply-templates select="multiplicity" mode="tostring"/>)
    <xsl:apply-templates select="." mode="desc"/>
    *
    """

    </xsl:template>

    <xsl:template match="composition[multiplicity/maxOccurs = 1]" mode="declare">
        <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
        <xsl:call-template name="vodmlAnnotation"/>
        <xsl:text>

    </xsl:text>
        <xsl:value-of select="concat(name,': ',$type,' = dataclasses.field(kw_only=True, default=None)')"/><xsl:text>
    """
    * Composition </xsl:text><xsl:value-of select="name"/> : ( Multiplicity : <xsl:apply-templates select="multiplicity" mode="tostring"/>)
    *
    *    <xsl:apply-templates select="." mode="desc" />
    """

    </xsl:template>


  <xsl:template match="reference" mode="declare"><!-- IMPL could be the same as attribute - actually more usefully so if reference allowed to have >1 multiplicity -->
    <xsl:variable name="type" select="vf:PythonType(datatype/vodml-ref)"/>
    <xsl:call-template name="vodmlAnnotation"/><xsl:text>
    </xsl:text>
      <xsl:value-of select="concat(name, ': ', $type)"/><xsl:text>
    """
    * ReferenceObject </xsl:text><xsl:value-of select="name"/> :
    * <xsl:apply-templates select="." mode="desc" />
    * ( Multiplicity : <xsl:apply-templates select="multiplicity" mode="tostring"/>) """
  </xsl:template>


    <xsl:template match="literal" >
    <xsl:variable name="up">
      <xsl:call-template name="constant">
        <xsl:with-param name="text" select="name"/>
      </xsl:call-template>
    </xsl:variable>
        <xsl:text>
    </xsl:text><xsl:value-of select="$up"/> = <xsl:value-of select="count(preceding-sibling::literal)"/>
    """
    * Value <xsl:value-of select="name"/> :
    *
    * <xsl:apply-templates select="." mode="desc" />
    """
  </xsl:template>

  <xsl:template match="*" mode="desc">
    <xsl:choose>
      <xsl:when test="count(description) > 0 and normalize-space(description) != 'TODO : Missing description : please, update your UML model asap.'">
          <xsl:value-of select="description" disable-output-escaping="yes"/>
          <xsl:if test="not(ends-with(normalize-space(description/text()), '.'))">
              <xsl:value-of select="'.'"/>
          </xsl:if>
      </xsl:when>
      <xsl:otherwise>
<!--       <xsl:message >TODO : <xsl:value-of select="name"/> Missing description : please, update your VO-DML model asap.</xsl:message> -->
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>  



  <xsl:template match="vo-dml:model" mode="packageDesc">
      <xsl:variable name="file" select="concat($root_package_dir,'/__init__.py')"/>
      <!-- open file for this class -->
      <xsl:message >Writing package info file <xsl:value-of select="$file"/></xsl:message>
      <xsl:result-document href="{$file}" format="python" >
"""
          <xsl:value-of select="title"/>

          <xsl:value-of select="description"/>
"""
     </xsl:result-document>
  </xsl:template>

   <xsl:template name="vodmlAnnotation">
     <!-- nothing for now -->
 </xsl:template>


</xsl:stylesheet>
