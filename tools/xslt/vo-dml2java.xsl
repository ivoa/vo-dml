<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE stylesheet [
<!ENTITY cr "<xsl:text>
</xsl:text>">
<!ENTITY bl "<xsl:text> </xsl:text>">
]>

<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:vo-dml="http://www.ivoa.net/xml/VODML/v1"
                xmlns:vf="http://www.ivoa.net/xml/VODML/functions"
                xmlns:exsl="http://exslt.org/common"
                xmlns:map="http://www.ivoa.net/xml/vodml-binding/v0.9"
                xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
                extension-element-prefixes="exsl"
                exclude-result-prefixes="map" 
                >
<!-- 
  This XSLT script transforms a data model in VO-DML/XML representation to 
  Purely Ordinary Java Classes.
  
  Only defines fields for components.
  Only argumentless constructor.
  
  Java 1.8 is required by these two libraries.
  
  Gerard Lemson (mpa)/Laurent Bourges (grenoble), Paul Harrison (JBO)
-->

  <xsl:import href="common-binding.xsl"/>
  <xsl:include href="jaxb.xsl"/>
  <xsl:include href="jpa.xsl"/>
 
 

  <xsl:output method="text" encoding="UTF-8" indent="yes" />
  <xsl:output name="packageInfo" method="html" encoding="UTF-8" doctype-public="-//W3C//DTD HTML 4.01 Transitional//EN"/>
    <xsl:output name="packageInfoJ" method="text" encoding="UTF-8"/>

  <xsl:strip-space elements="*" />


  <xsl:param name="lastModified"/>
  <xsl:param name="lastModifiedText"/>
  <xsl:param name="output_root" />
  <xsl:param name="vo-dml_package" select="'org.ivoa.vodml.model'"/>
  <xsl:param name="binding"/>
  <xsl:variable name="vodmlauthor" select="'@author generated by https://github.com/ivoa/vo-dml tools'"/>
    <xsl:variable name="lt">&lt;</xsl:variable>
    <xsl:variable name="gt">&gt;</xsl:variable>
  <xsl:variable name="mapping">
  <xsl:message>setting mapping</xsl:message>
    <map:mappedModels>
      <xsl:for-each select="tokenize($binding,',')">
      <xsl:message><xsl:value-of select="."/></xsl:message>
          <xsl:copy-of
                  select="document(normalize-space(.))/map:mappedModels/model" />
      </xsl:for-each>
    </map:mappedModels>
  </xsl:variable>
 
 <!-- load all models at start -->
  <xsl:variable name="models">
     <xsl:message>setting models</xsl:message>
      <xsl:for-each select="$mapping/map:mappedModels/model">
         <xsl:choose>
            <xsl:when test="file"> <!-- prefer local file for reading defn -->
            <xsl:message>opening file <xsl:value-of select="file"/></xsl:message>
               <xsl:copy-of
                  select="document(file)/vo-dml:model" />
            </xsl:when>
            <xsl:when test="url">
               <xsl:copy-of
                  select="document(url)/vo-dml:model" />
            </xsl:when>
            <xsl:otherwise>
               <xsl:message>Model <xsl:value-of select="vodml-id" />has neither url nor file, hence no artifacts will be generated.</xsl:message>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:for-each>
   </xsl:variable>
 

  <!-- next could be parameters -->


  <!-- main pattern : processes for root node model -->
  <xsl:template match="/">
  <xsl:message >Generating Java - considering models <xsl:value-of select="string-join($models/vo-dml:model/name,' and ')" /></xsl:message>
  <xsl:apply-templates/>
 </xsl:template>

  <!-- model pattern : generates gen-log and processes nodes package and generates the ModelVersion class and persistence.xml -->
  <xsl:template match="vo-dml:model">
    <xsl:message>
-------------------------------------------------------------------------------------------------------
-- Generating Java code for model <xsl:value-of select="name"/> [<xsl:value-of select="title"/>].
-- last modification date of the model <xsl:value-of select="lastModified"/>
-------------------------------------------------------------------------------------------------------
    </xsl:message>

    <xsl:variable name="prefix" select="name"/>
      <xsl:if test="not($mapping/map:mappedModels/model[name=$prefix])">
          <xsl:message terminate="yes">
              There is no binding for model <xsl:value-of select="$prefix"/>
          &cr;
          </xsl:message>
      </xsl:if>
      <xsl:variable name="root_package" select="$mapping/map:mappedModels/model[name=$prefix]/java-package"/>
      <xsl:variable name="root_package_dir" select="replace($root_package,'[.]','/')"/>

      <!--
          <xsl:message>root_package = <xsl:value-of select="$root_package"/></xsl:message>
          <xsl:message>root_package_dir = <xsl:value-of select="$root_package_dir"/></xsl:message>
       -->

      <!-- don't do model factory for now
    <xsl:apply-templates select="." mode="modelFactory">
      <xsl:with-param name="root_package" select="$root_package"/>
      <xsl:with-param name="root_package_dir" select="$root_package_dir"/>
    </xsl:apply-templates>
    -->

       <xsl:apply-templates select="." mode="modelClass">
          <xsl:with-param name="root_package" select="$root_package"/>
          <xsl:with-param name="root_package_dir" select="$root_package_dir"/>
      </xsl:apply-templates>

      <xsl:apply-templates select="." mode="content">
      <xsl:with-param name="dir" select="$root_package_dir"/>
      <xsl:with-param name="path" select="$root_package"/>
    </xsl:apply-templates>

      <xsl:apply-templates select="." mode="jpaConfig" />

  </xsl:template>  




  <xsl:template match="vo-dml:model|package" mode="content">
    <xsl:param name="dir"/>
    <xsl:param name="path"/>

    <xsl:variable name="newdir">
      <xsl:choose>
        <xsl:when test="$dir and ./name() = 'package'">
          <xsl:value-of select="concat($dir,'/',name)"/>
        </xsl:when>
        <xsl:when test="$dir and ./name() = 'vo-dml:model'">
          <xsl:value-of select="$dir"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="name"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
   
    <xsl:variable name="newpath">
      <xsl:choose>
        <xsl:when test="$path and ./name() = 'package'">
          <xsl:value-of select="concat($path,'.',name)"/>
        </xsl:when>
        <xsl:when test="$path and ./name() = 'vo-dml:model'">
          <xsl:value-of select="$path"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="name"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
   
    <xsl:message>package = <xsl:value-of select="$newpath"></xsl:value-of></xsl:message>

      <xsl:apply-templates select="." mode="packageDesc">
          <xsl:with-param name="dir" select="$newdir"/>
          <xsl:with-param name="path" select="$newpath"/>
      </xsl:apply-templates>

      <xsl:apply-templates select="." mode="jaxb.index">
          <xsl:with-param name="dir" select="$newdir"/>
      </xsl:apply-templates>




      <xsl:apply-templates select="objectType|dataType|enumeration|primitiveType" mode="file">
      <xsl:with-param name="dir" select="$newdir"/>
      <xsl:with-param name="path" select="$newpath"/>
    </xsl:apply-templates>

    <xsl:apply-templates select="package" mode="content">
      <xsl:with-param name="dir" select="$newdir"/>
      <xsl:with-param name="path" select="$newpath"/>
    </xsl:apply-templates>

  </xsl:template>


  <xsl:template match="objectType|dataType|enumeration|primitiveType" mode="file">
    <xsl:param name="dir"/>
    <xsl:param name="path"/>

    <xsl:variable name="vodml-id" select="vodml-id" />
    <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
    <xsl:variable name="mappedtype">
      <xsl:call-template name="findmappingInThisModel">
        <xsl:with-param name="modelname" select="./ancestor::vo-dml:model/name"/>
        <xsl:with-param name="vodml-id" select="$vodml-id"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:choose>
    <xsl:when test="not($mappedtype) or $mappedtype = ''" >
      <xsl:variable name="file" select="concat($output_root, '/', $dir, '/', name, '.java')"/>

    <!-- open file for this class -->
      <xsl:message >Writing to Class file <xsl:value-of select="$file"/> base=<xsl:value-of select="vf:baseTypes($vodml-ref)/name"/> haschildren=<xsl:value-of select="vf:hasSubTypes($vodml-ref)"/> contained=<xsl:value-of select="vf:isContained($vodml-ref)"/> referredto=<xsl:value-of select="vf:referredTo($vodml-ref)"/> </xsl:message>
      
      <xsl:result-document href="{$file}">
        <xsl:apply-templates select="." mode="class">
          <xsl:with-param name="path" select="$path"/>
        </xsl:apply-templates>
      </xsl:result-document>
    </xsl:when>
      <xsl:otherwise>
       <xsl:message>1) Mapped type for <xsl:value-of select="$vodml-ref"/> = '<xsl:value-of select="$mappedtype"/>'</xsl:message>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

    <xsl:template match="objectType|dataType|primitiveType|enumeration" mode="typeimports">
        <!-- do not import types - always refer to fully qualified - makes life easier -->
       import javax.persistence.*;
    </xsl:template>


    <!-- returns the vodml-refs of the members including inherited ones -->
    <xsl:template name="allInheritedMembers" as="xsd:string*">
        <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
        <xsl:variable name="supers" select="(.,vf:baseTypes($vodml-ref))"/>
        <xsl:sequence>
            <xsl:for-each select="$supers/attribute,$supers/composition,$supers/reference">
               <xsl:value-of select="vf:asvodmlref(.)"/>
            </xsl:for-each>
        </xsl:sequence>
    </xsl:template>

    <xsl:template match="objectType|dataType" mode="builder">
        <xsl:variable name="members" as="xsd:string*">
            <xsl:call-template name="allInheritedMembers"/>
        </xsl:variable>
        <xsl:variable name="this" select="."/>
        /**
          A builder class for <xsl:value-of select="name"/> principally to be used in the functional builder pattern.
        */
        public static class <xsl:value-of select="name"/>Builder {
           <xsl:for-each select="$members">
               <xsl:variable name="m" select="$models/key('ellookup',current())"/>
           /**
           * <xsl:apply-templates select="$m" mode="desc"/>
           */<xsl:choose>
                   <xsl:when test="$this/constraint[ends-with(@xsi:type,':SubsettedRole')]/role[vodml-ref = current()]">
                       <xsl:variable name="type" select="vf:JavaType($this/constraint[role/vodml-ref = current()]/datatype/vodml-ref)"/>

                       <xsl:choose>
                           <xsl:when test="$models/key('memblookup',current())/multiplicity[maxOccurs != 1]">
           public <xsl:value-of select="concat(' java.util.List',$lt,$type,$gt, ' ', $models/key('ellookup',current())/name)"/>;
                           </xsl:when>
                           <xsl:otherwise>
           public <xsl:value-of select="concat(' ',$type, ' ', $models/key('ellookup',current())/name)"/>;
                           </xsl:otherwise>
                       </xsl:choose>

                   </xsl:when>
                   <xsl:otherwise>
           public <xsl:apply-templates select="$m" mode="paramDecl"/>;
                   </xsl:otherwise>
               </xsl:choose>

           </xsl:for-each>

           private <xsl:value-of select="name"/>Builder with (java.util.function.Consumer &lt;<xsl:value-of select="name"/>Builder&gt; f)
           {
             f.accept(this);
             return this;
           }
           /**
             create a <xsl:value-of select="name"/> from this builder.
           */
           public <xsl:value-of select="name"/> create()
           {
             return new <xsl:value-of select="name"/> (
             <xsl:value-of select="string-join(for $v in $members return tokenize($v,'[.]')[last()], ',')" />
             );
           }
         }
         /**
           create a <xsl:value-of select="name"/> in functional builder style.
         */
         public static <xsl:value-of select="name"/>&bl;create<xsl:value-of select="name"/> (java.util.function.Consumer &lt;<xsl:value-of select="name"/>Builder&gt; f)
         {
             return new <xsl:value-of select="name"/>Builder().with(f).create();
         }
    </xsl:template>

    <!-- generate a all member constructor
      The general tactic is to look for all supertype members and initialize them in the one constructor, because it
       is easier to generate than calling super constructors with their appropriate parameters.
    -->
    <xsl:template match="objectType|dataType" mode="constructor">
        <xsl:variable name="members" as="xsd:string*"  >
            <xsl:call-template name="allInheritedMembers" />
        </xsl:variable>
        <xsl:variable name="this" select="."/>
        <xsl:variable name="decls" as="xsd:string*">
                <xsl:for-each select="$members">
                    <xsl:choose>
                        <xsl:when test="$this/constraint[ends-with(@xsi:type,':SubsettedRole')]/role[vodml-ref = current()]">
                           
                            <xsl:variable name="type" select="vf:JavaType($this/constraint[role/vodml-ref=current()]/datatype/vodml-ref)"/>
                            <xsl:choose>
                                <xsl:when test="$models/key('memblookup',current())/multiplicity[maxOccurs != 1]">
                                    <xsl:value-of select="concat('final java.util.List', $lt, $type, $gt, ' ', tokenize(current(), '[.]' )[last()])"/>
                                </xsl:when>
                                <xsl:otherwise>
                                    <xsl:value-of select="concat('final ',$type, ' ', tokenize(current(), '[.]' )[last()])"/>
                                </xsl:otherwise>
                            </xsl:choose>

                        </xsl:when>
                        <xsl:otherwise><xsl:value-of>
                            <xsl:text>final </xsl:text>
                            <xsl:apply-templates select="$models/key('ellookup',current())" mode="paramDecl"/>
                        </xsl:value-of>
                        </xsl:otherwise>
                    </xsl:choose>

                </xsl:for-each>
        </xsl:variable>
        <xsl:if test="count($members) > 0">
        /**
        * full parameter constructor.
        */
        public  <xsl:value-of select="name"/> (
          <xsl:value-of select="string-join($decls,', ')"/>
        )
        {
           <xsl:for-each select="$members">
               <xsl:variable name="name" select="$models/key('ellookup',current())/name"/>
           this.<xsl:value-of select="$name"/> = <xsl:value-of select="$name"/>;
           </xsl:for-each>
        }
        </xsl:if>
    </xsl:template>

  <xsl:template match="attribute|composition|reference" mode="paramDecl">
      <xsl:variable name="type" select="vf:JavaType(datatype/vodml-ref)"/>
      <xsl:choose>
          <xsl:when test="name()='composition' and multiplicity/maxOccurs != 1" >
              <xsl:choose>
                  <xsl:when test="vf:isSubSetted(vf:asvodmlref(.))">
                      <xsl:value-of select="concat('java.util.List',$lt,'? extends ',$type,$gt, ' ',name)" />
                  </xsl:when>
                  <xsl:otherwise>
                      <xsl:value-of select="concat('java.util.List',$lt,$type,$gt, ' ',name)" />
                  </xsl:otherwise>
              </xsl:choose>

          </xsl:when>
          <xsl:otherwise>
              <xsl:choose>
                  <xsl:when test="xsd:int(multiplicity/maxOccurs) gt 1">
                      <xsl:value-of select="concat($type, '[] ',name)" />
                  </xsl:when>
                  <xsl:when test="multiplicity/maxOccurs = -1">
                      <xsl:value-of select="concat('java.util.List',$lt,$type,$gt, ' ',name)" />
                  </xsl:when>
                  <xsl:otherwise>
                      <xsl:value-of select="concat($type, ' ',name)" />
                  </xsl:otherwise>
              </xsl:choose>

          </xsl:otherwise>
      </xsl:choose>

  </xsl:template>

    <!-- template class creates a java class (JPA compliant) for UML object & data types -->
  <xsl:template match="objectType|dataType" mode="class">
    <xsl:param name="path"/>
    <xsl:variable name="vodml-ref"><xsl:apply-templates select="vodml-id" mode="asvodml-ref"/></xsl:variable>
  package <xsl:value-of select="$path"/>;

    <!-- imports -->
    <xsl:if test="composition">
      import java.util.List;
      import java.util.ArrayList;
    </xsl:if>
    <xsl:apply-templates select="." mode="typeimports"/>
/**
* <xsl:apply-templates select="." mode="desc" />
*
* <xsl:value-of select="name()"/>: &bl;<xsl:value-of select="name" />
*
* <xsl:value-of select="$vodmlauthor"/>
*/
    <xsl:apply-templates select="." mode="JPAAnnotation"/>
    <xsl:apply-templates select="." mode="JAXBAnnotation"/>
    <xsl:call-template name="vodmlAnnotation"/>
       public&bl;<xsl:if test="@abstract='true'">abstract</xsl:if>&bl;class <xsl:value-of select="name"/>&bl;
      <xsl:if test="extends">extends <xsl:value-of select="vf:JavaType(extends/vodml-ref)"/></xsl:if>
      <xsl:if test="vf:referredTo($vodml-ref)"> implements org.ivoa.vodml.jaxb.XmlIdManagement</xsl:if>
    &bl;{
      <xsl:if test="local-name() eq 'objectType' and not (extends) and not(attribute/constraint[ends-with(@xsi:type,':NaturalKey')])" >
          /**
          * inserted database key
          */
          @javax.xml.bind.annotation.XmlTransient
          @Id
          @GeneratedValue
          @Column(name = "ID")
          protected Long _id = (long) 0;

          /**
          * @return the id
          */
          public Long getId() {
          return _id;
          }

          <xsl:if test="vf:referredTo($vodml-ref)">
              /**
              * getter for XMLID
              */

              @javax.xml.bind.annotation.XmlAttribute(name = "id" )
              @javax.xml.bind.annotation.XmlID
              @Override
              public String getXmlId(){
              return _id.toString();
              }
              @Override
              public void setXmlId (String id)
              {
              this._id = Long.parseLong(id);
              }
              @Override
              public boolean hasNaturalKey()
              {
                return false;
              }
          </xsl:if>


      </xsl:if>
<!-- 
      /** serial uid = last modification date of the UML model */
      private static final long serialVersionUID = LAST_MODIFICATION_DATE;
 -->
      <xsl:apply-templates select="attribute" mode="declare" />
      <xsl:apply-templates select="composition" mode="declare" />
      <xsl:apply-templates select="reference" mode="declare" />
      /**
       * Creates a new <xsl:value-of select="name"/>
       */
      public <xsl:value-of select="name"/>() {
        super();
      }
      <xsl:apply-templates select="." mode="constructor"/>

      <xsl:apply-templates select="attribute|reference|composition|constraint[ends-with(@xsi:type,':SubsettedRole')]" mode="getset"/>

      <xsl:if test="vf:referredTo($vodml-ref) and attribute/constraint[ends-with(@xsi:type,':NaturalKey')]">
          <!--TODO deal with multiple natural keys -->
          <!-- TODO this assumes that the natural key is a string -->
          @Override
          public String getXmlId(){
          return <xsl:value-of select="attribute[ends-with(constraint/@xsi:type,':NaturalKey')]/name"/>;
          }
          @Override
          public void setXmlId (String id)
          {
          this.<xsl:value-of select="attribute[ends-with(constraint/@xsi:type,':NaturalKey')]/name"/> = id;
          }
          @Override
          public boolean hasNaturalKey()
          {
          return true;
          }

      </xsl:if>

      <xsl:if test="not(@abstract)">
      <xsl:apply-templates select="." mode="builder"/>
      </xsl:if>
<!--      <xsl:if test="local-name() eq 'dataType'">-->
<!--          <xsl:apply-templates select="." mode="JPAConverter"/>-->
<!--      </xsl:if>-->
}
  </xsl:template>




  <xsl:template match="enumeration" mode="class">
    <xsl:param name="dir"/>
    <xsl:param name="path"/>
package <xsl:value-of select="$path"/>;

      /**
      * <xsl:apply-templates select="." mode="desc" />
      *
      * Enumeration <xsl:value-of select="name"/> :
      *
      * <xsl:value-of select="$vodmlauthor"/>
      */
      public enum <xsl:value-of select="name"/>&bl;{

        <xsl:apply-templates select="literal"  />

        /** string representation */
        private final String value;

        /**
         * Creates a new <xsl:value-of select="name"/> Enumeration Literal
         *
         * @param v string representation
         */
        <xsl:value-of select="name"/>(final String v) {
            value = v;
        }

        /**
         * Return the string representation of this enum constant (value)
         * @return string representation of this enum constant (value)
         */
        public final String value() {
            return this.value;
        }

        /**
         * Return the string representation of this enum constant (value)
         * @see #value()
         * @return string representation of this enum constant (value)
         */
        @Override
        public final String toString() {
            return value();
        }

        /**
         * Return the <xsl:value-of select="name"/> enum constant corresponding to the given string representation (value)
         *
         * @param v string representation (value)
         *
         * @return <xsl:value-of select="name"/> enum constant
         *
         * @throws IllegalArgumentException if there is no matching enum constant
         */
        public final static <xsl:value-of select="name"/> fromValue(final String v) {
          for (<xsl:value-of select="name"/> c : <xsl:value-of select="name"/>.values()) {
              if (c.value.equals(v)) {
                  return c;
              }
          }
          throw new IllegalArgumentException("<xsl:value-of select="name"/>.fromValue : No enum const for the value : " + v);
        }

      }
  </xsl:template>

  <xsl:template match="primitiveType" mode="class">
    <xsl:param name="path"/>

    <xsl:variable name="valuetype">
      <xsl:choose>
        <xsl:when test="extends">
          <xsl:value-of select="vf:JavaType(extends/vodml-ref)"/>
        </xsl:when>
        <xsl:otherwise>
            <xsl:message>Primitive type <xsl:value-of select="name"/> is being represented as a String - in general it is probably best to specialize primitive types with the binding mechanism to get desired representation/behavious</xsl:message>
            <xsl:value-of select="'String'"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
package <xsl:value-of select="$path"/>;
        <xsl:apply-templates select="." mode="typeimports" />
<!---->

      /**
      *  <xsl:apply-templates select="." mode="desc" />
      *  PrimitiveType <xsl:value-of select="name"/> :
      *
      *  <xsl:value-of select="$vodmlauthor"/>
      */
      <xsl:call-template name="vodmlAnnotation"/>
      <xsl:apply-templates select="." mode="JPAAnnotation"/>
      <xsl:apply-templates select="." mode="JAXBAnnotation"/>
      public class <xsl:value-of select="name"/>&bl; implements java.io.Serializable {

        private static final long serialVersionUID = 1L;

        /**  representation */
        @javax.xml.bind.annotation.XmlValue
        private <xsl:value-of select="$valuetype"/> value;

        /**
         * Creates a new <xsl:value-of select="name"/> Primitive Type instance, wrapping a base type.
         *
         * @param v 
         */
        public <xsl:value-of select="name"/>(final <xsl:value-of select="$valuetype"/> v) {
            this.value = v;
        }
        /**
         * no arg constructor.
         */
        protected <xsl:value-of select="name"/>() {}

        /**
         * Return the representation of this primitive (value)
         * @return string representation of this primitive( value)
         */
        public final <xsl:value-of select="$valuetype"/> value() {
            return this.value;
        }

        /**
         * Return the string representation of this primitive value
         * @see #value()
         * @return string representation of this primitive
         */
        @Override
        public final String toString() {
            return value().toString();
        }
              

      }
  </xsl:template>



  <xsl:template match="attribute" mode="declare">
    <xsl:variable name="type" select="vf:JavaType(datatype/vodml-ref)"/>
    /** 
    * <xsl:apply-templates select="." mode="desc" /> : Attribute <xsl:value-of select="name"/> : multiplicity <xsl:apply-templates select="multiplicity" mode="tostring"/>
    *
    */
    <xsl:call-template name="vodmlAnnotation"/>
    <xsl:apply-templates select="." mode="JPAAnnotation"/>
    <xsl:apply-templates select="." mode="JAXBAnnotation"/>
    <xsl:choose>
        <xsl:when test="xsd:int(multiplicity/maxOccurs) gt 1">
    protected <xsl:value-of select="concat($type,'[] ',name)"/>;
        </xsl:when>
        <xsl:when test="xsd:int(multiplicity/maxOccurs) lt 0">
    protected <xsl:value-of select="concat('java.util.List',$lt,$type,$gt,' ',name)"/>;
        </xsl:when>
        <xsl:otherwise>
    protected <xsl:value-of select="concat($type,' ',name)"/>;
        </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

  <xsl:template match="constraint[ends-with(@xsi:type,':SubsettedRole')]" mode="getset">

      <xsl:variable name="name" select="tokenize(role/vodml-ref/text(),'[.]')[last()]"/>
      <xsl:if test="$models/key('ellookup',current()/datatype/vodml-ref)[local-name() eq 'dataType']">
        @Embedded
      </xsl:if>
      <xsl:call-template name="doGetSet">
          <xsl:with-param name="name" select="$name"/>
          <xsl:with-param name="mult" select="$models/key('memblookup',current()/role/vodml-ref)/multiplicity"/>
      </xsl:call-template>

  </xsl:template>


  <xsl:template match="(attribute|composition[multiplicity/maxOccurs = 1])" mode="getset">
    <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
<!--      <xsl:message>attribute <xsl:value-of select="concat($vodml-ref,' from ', parent::*/name,' ', parent::*/@abstract, ' ', vf:isSubSetted($vodml-ref) )" /></xsl:message>-->
      <xsl:if test="not(parent::*/@abstract and vf:isSubSetted($vodml-ref))">
          <xsl:call-template name="doGetSet"/>
       </xsl:if>

   </xsl:template>

    <xsl:template name="doGetSet">
        <xsl:param name="name" select="name"/>
        <xsl:param name="type" select="vf:JavaType(datatype/vodml-ref)"/>
        <xsl:param name="mult" select="multiplicity"/>

        <xsl:variable name="upName">
            <xsl:call-template name="upperFirst">
                <xsl:with-param name="val" select="$name"/>
            </xsl:call-template>
        </xsl:variable>
        <xsl:variable name="fulltype">
            <xsl:choose>
                <xsl:when test="xsd:int($mult/maxOccurs) =-1"><xsl:value-of select="concat('java.util.List',$lt,$type,$gt)"/></xsl:when><!--TODO think about arrays -->
                <xsl:when test="xsd:int($mult/maxOccurs)  gt 1"><xsl:value-of select="concat($type,'[]')"/></xsl:when>
                <xsl:otherwise><xsl:value-of select="$type"/></xsl:otherwise>
            </xsl:choose>
        </xsl:variable>
        /**
        * Returns <xsl:value-of select="$name"/> Attribute
        * @return <xsl:value-of select="$name"/> Attribute
        */
        <xsl:if test="$mult/maxOccurs != 1">@SuppressWarnings("unchecked")</xsl:if><!--the cast should be ok even for the list-->
        public <xsl:value-of select="$fulltype"/>&bl;get<xsl:value-of select="$upName"/>() {
        return (<xsl:value-of select="$fulltype"/>)this.<xsl:value-of select="$name"/>;
        }
        <!-- cannot need to rely on most generic set if list of subsetted type, because of type erasure - IMPL might be able to do something clever with type argument on the base class, but gets tricky if there is more than one level of subclassing -->
        <xsl:if test="not(parent::*/extends and current()[ends-with(@xsi:type,':SubsettedRole')] and $mult/maxOccurs != 1)">
        /**
        * Defines <xsl:value-of select="$name"/> Attribute
        * @param p<xsl:value-of select="$upName"/> value to set
        */
        public void set<xsl:value-of select="$upName"/>(final <xsl:value-of select="$fulltype"/> p<xsl:value-of select="$upName"/>) {
        this.<xsl:value-of select="$name"/> = p<xsl:value-of select="$upName"/>;
        }
        </xsl:if>

        public <xsl:value-of select="vf:JavaType(vf:asvodmlref(parent::*))"/>&bl;with<xsl:value-of select="$upName"/>(final <xsl:value-of select="$fulltype"/> p<xsl:value-of select="$upName"/>) {
        this.<xsl:value-of select="$name"/> = p<xsl:value-of select="$upName"/>;
        return this;
        }

    </xsl:template>

  <xsl:template match="attribute" mode="setProperty">
    <xsl:variable name="type" select="vf:JavaType(datatype/vodml-ref)"/>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
      set<xsl:value-of select="$name"/>((<xsl:value-of select="$type"/><xsl:if test="contains(multiplicity,'*')">[]</xsl:if>)pValue);
      return true;
    }
  </xsl:template>

  <xsl:template match="attribute" mode="setStringProperty">
    <xsl:variable name="type" select="vf:JavaType(datatype/vodml-ref)"/>
    <xsl:variable name="element" as="element()" select="vf:Element4vodml-ref(datatype/vodml-ref)"/>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:if test="$element/name() = 'enumeration' or $element/name() = 'primitiveType'">
    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
     <xsl:choose>
       <xsl:when test="$element/name() = 'enumeration'">
             set<xsl:value-of select="$name"/>(<xsl:value-of select="$type"/>.fromValue(pValue));
       </xsl:when>
       <xsl:otherwise>
      set<xsl:value-of select="$name"/>(new <xsl:value-of select="$type"/>(pValue));
       </xsl:otherwise>
     </xsl:choose>
      return true;
    }
    </xsl:if>
  </xsl:template>



  <xsl:template match="composition[multiplicity/maxOccurs != 1]" mode="declare">
    <xsl:variable name="type" select="vf:JavaType(datatype/vodml-ref)"/>
    /**
    * <xsl:apply-templates select="." mode="desc" />
    * composition <xsl:value-of select="name"/> :
    * (
    * Multiplicity : <xsl:apply-templates select="multiplicity" mode="tostring"/>
    * )
    */
    <xsl:apply-templates select="." mode="JAXBAnnotation"/>
    <xsl:apply-templates select="." mode="JPAAnnotation"/>
    <xsl:call-template name="vodmlAnnotation"/>
      <xsl:choose>
          <xsl:when test="vf:isSubSetted(vf:asvodmlref(.))">
     protected List&lt;? extends <xsl:value-of select="$type"/>&gt;&bl;<xsl:value-of select="name"/> = null; // IMPL is subsetted
          </xsl:when>
          <xsl:otherwise>
     protected List&lt;<xsl:value-of select="$type"/>&gt;&bl;<xsl:value-of select="name"/> = null;
          </xsl:otherwise>
      </xsl:choose>

  </xsl:template>

    <xsl:template match="composition[multiplicity/maxOccurs = 1]" mode="declare">
        <xsl:variable name="type" select="vf:JavaType(datatype/vodml-ref)"/>
        /**
        * <xsl:apply-templates select="." mode="desc" />
        * composition <xsl:value-of select="name"/> :
        * (
        * Multiplicity : <xsl:apply-templates select="multiplicity" mode="tostring"/>
        * )
        */
        <xsl:apply-templates select="." mode="JAXBAnnotation"/>
        <xsl:apply-templates select="." mode="JPAAnnotation"/>
        <xsl:call-template name="vodmlAnnotation"/>
        protected <xsl:value-of select="$type"/>&bl;<xsl:value-of select="name"/> = null;
    </xsl:template>




    <!-- define methods for getting/setting and adding to composition -->
  <xsl:template match="composition[multiplicity/maxOccurs != 1]" mode="getset">
    <xsl:variable name="type" select="vf:JavaType(datatype/vodml-ref)"/>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="datatype" select="substring-after(datatype/vodml-ref,':')"/>
    
    /**
    * Returns <xsl:value-of select="name"/> composition
    * @return <xsl:value-of select="name"/> composition
    */
      <xsl:choose>
      <xsl:when test="vf:isSubSetted(vf:asvodmlref(.))">
      public List&lt;? extends <xsl:value-of select="$type"/>&gt;&bl;get<xsl:value-of select="$name"/>() { // is subsetted
      </xsl:when>
      <xsl:otherwise>
      public List&lt;<xsl:value-of select="$type"/>&gt;&bl;get<xsl:value-of select="$name"/>() {
      </xsl:otherwise>
      </xsl:choose>
    return this.<xsl:value-of select="name"/>;
    }
    /**
    * Defines <xsl:value-of select="name"/> composition
    * @param p<xsl:value-of select="$name"/> composition to set
    */
    <xsl:choose>
        <xsl:when test="vf:isSubSetted(vf:asvodmlref(.))">
    public void set<xsl:value-of select="$name"/>(final List&lt;? extends <xsl:value-of select="$type"/>&gt; p<xsl:value-of select="$name"/>) {
        </xsl:when>
        <xsl:otherwise>
    public void set<xsl:value-of select="$name"/>(final List&lt;<xsl:value-of select="$type"/>&gt; p<xsl:value-of select="$name"/>) {
        </xsl:otherwise>
    </xsl:choose>
    this.<xsl:value-of select="name"/> = p<xsl:value-of select="$name"/>;
    }
    <xsl:if test="not(vf:isSubSetted(vf:asvodmlref(.)))">
    /**
    * Add a <xsl:value-of select="$type"/> to the composition
    * @param p&bl;<xsl:value-of select="$type"/> to add
    */
    public void add<xsl:value-of select="$name"/>(final <xsl:value-of select="$type"/> p) {
      if(this.<xsl:value-of select="name"/> == null) {
        this.<xsl:value-of select="name"/> = new ArrayList&lt;&gt;();
      }
      this.<xsl:value-of select="name"/>.add(p);
    }
    </xsl:if>
  </xsl:template>

  <xsl:template match="composition[multiplicity/maxOccurs != 1]" mode="add2composition">
    <xsl:variable name="type" select="vf:JavaType(datatype/vodml-ref)"/>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
      add<xsl:value-of select="$name"/>((<xsl:value-of select="$type"/>)object);
      return true;
    }
  </xsl:template>



  <xsl:template match="reference" mode="declare"><!-- IMPL could be the same as attribute - actually more usefully so if reference allowed to have >1 multiplicity -->
    <xsl:variable name="type" select="vf:JavaType(datatype/vodml-ref)"/>
    /** 
    * ReferenceObject <xsl:value-of select="name"/> :
    * <xsl:apply-templates select="." mode="desc" />
    * (
    * Multiplicity : <xsl:apply-templates select="multiplicity" mode="tostring"/>
    * )
    */
    <xsl:apply-templates select="." mode="JPAAnnotation"/>
    <xsl:apply-templates select="." mode="JAXBAnnotation"/>
    <xsl:call-template name="vodmlAnnotation"/>
    protected <xsl:value-of select="$type"/>&bl;<xsl:value-of select="name"/> = null;
  </xsl:template>




  <xsl:template match="reference" mode="getset">
    <xsl:variable name="type" select="vf:JavaType(datatype/vodml-ref)"/>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    /**
    * Returns <xsl:value-of select="name"/> Reference<br/>
    * @return <xsl:value-of select="name"/> Reference
    */
    public <xsl:value-of select="$type"/>&bl;get<xsl:value-of select="$name"/>() {
        return this.<xsl:value-of select="name"/>;
    }
    /**
    * Defines <xsl:value-of select="name"/> Reference
    * @param p<xsl:value-of select="$name"/> reference to set
    */
    public void set<xsl:value-of select="$name"/>(final <xsl:value-of select="$type"/> p<xsl:value-of select="$name"/>) {
        this.<xsl:value-of select="name"/> = p<xsl:value-of select="$name"/>;
    }
  </xsl:template>




  <xsl:template match="reference" mode="setProperty">
    <xsl:variable name="type" select="vf:JavaType(datatype/vodml-ref)"/>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>

    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
      if(pValue instanceof ReferenceObject)
        set<xsl:value-of select="$name"/>((ReferenceObject)pValue);
      else 
        set<xsl:value-of select="$name"/>((<xsl:value-of select="$type"/>)pValue);
      return true;
    }
  </xsl:template>

  <xsl:template match="literal" >
    /** 
    * Value <xsl:value-of select="name"/> :
    * 
    * <xsl:apply-templates select="." mode="desc" />
    */
    <xsl:variable name="up">
      <xsl:call-template name="constant">
        <xsl:with-param name="text" select="name"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:value-of select="$up"/>("<xsl:value-of select="name"/>")
    <xsl:choose>
      <xsl:when test="position() != last()"><xsl:text>,</xsl:text></xsl:when>
      <xsl:otherwise><xsl:text>;</xsl:text></xsl:otherwise>
    </xsl:choose>
    &cr;
  </xsl:template>


  <xsl:template match="attribute|reference|composition" mode="getProperty">
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
      return get<xsl:value-of select="$name"/>();
    }
  </xsl:template>




  <xsl:template match="*" mode="desc">
    <xsl:choose>
      <xsl:when test="count(description) > 0 and normalize-space(description) != 'TODO : Missing description : please, update your UML model asap.'">
          <xsl:value-of select="description" disable-output-escaping="yes"/>
          <xsl:if test="not(ends-with(normalize-space(description/text()), '.'))">
              <xsl:value-of select="'.'"/>
          </xsl:if>
      </xsl:when>
      <xsl:otherwise>
<!--       <xsl:message >TODO : <xsl:value-of select="name"/> Missing description : please, update your VO-DML model asap.</xsl:message> -->
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>  




  <!-- specific documents --> 

  <!-- ModelVersion.java -->
  <xsl:template match="vo-dml:model" mode="modelFactory">
    <xsl:param name="root_package"/>
    <xsl:param name="root_package_dir"/>
    <xsl:variable name="file" select="concat($output_root,'/', $root_package_dir,'/','ModelFactory.java')"/>
    <!-- open file for this class -->
    <xsl:message >Writing Factory file <xsl:value-of select="$file"/></xsl:message>
    <xsl:result-document href="{$file}">package <xsl:value-of select="$root_package"/>;
      <xsl:if test="descendant-or-self::objectType|descendant-or-self::dataType">
      import <xsl:value-of select="$vo-dml_package"/>.StructuredObject;
      </xsl:if>
      /**
      * Factory class for model <xsl:value-of select="name"/>.
      *
      * <xsl:apply-templates select="." mode="desc" />
      *
      * <xsl:value-of select="$vodmlauthor"/>
      */
      public class ModelFactory extends <xsl:value-of select="$vo-dml_package"/>.ModelFactory { 

        /** last modification date of the VODML model */
        public final static String LAST_MODIFICATION_DATE = "<xsl:value-of select="lastModified"/>";

        <xsl:if test="descendant-or-self::objectType|descendant-or-self::dataType">
        @Override
        public StructuredObject newStructuredObject(String vodmlRef)
        {
          if(vodmlRef == null)
            return null;
          <xsl:for-each select="descendant-or-self::objectType|descendant-or-self::dataType" >
          <xsl:if test="not(@abstract = 'true')">
            <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
            <xsl:variable name="type" select="vf:QualifiedJavaType($vodml-ref)"/>

           else if("<xsl:value-of select="$vodml-ref"/>".equals(vodmlRef))
            return new <xsl:value-of select="$type"/>();
            </xsl:if>
          </xsl:for-each>  
          return null;
        }
        </xsl:if>
        <xsl:if test="descendant-or-self::enumeration">
        @Override
        public Object newEnumeratedValue(String vodmlRef, String value)
        {
          if(vodmlRef == null)
            return null;
          <xsl:for-each select="descendant-or-self::enumeration">
            <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
          <xsl:if test="not(@abstract = 'true')">
          else if("<xsl:value-of select="$vodml-ref"/>".equals(vodmlRef))
            return <xsl:apply-templates select="." mode="path"/>.fromValue(value);
            </xsl:if>
          </xsl:for-each>  
          return null;
        }
        </xsl:if>
        <xsl:if test="descendant-or-self::primitiveType">
        @Override
        public Object newPrimitiveValue(String vodmlRef, String value)
        {
          if(vodmlRef == null)
            return null;
          <xsl:for-each select="descendant-or-self::primitiveType">
            <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
            <xsl:variable name="type" select="vf:QualifiedJavaType($vodml-ref)"/>
          else if("<xsl:value-of select="$vodml-ref"/>".equals(vodmlRef))
            return new <xsl:value-of select="$type"/>(value);
          </xsl:for-each>  
          return null;
        }
        </xsl:if>
      }
    </xsl:result-document>
  </xsl:template>




  <!-- package.html -->
  <xsl:template match="vo-dml:model|package" mode="packageDesc">
    <xsl:param name="dir"/>
      <xsl:param name="path"/>
    <xsl:variable name="file" select="concat($output_root,'/',$dir,'/package.html')"/>
    <!-- open file for this class -->
    <xsl:message >Writing package file <xsl:value-of select="$file"/></xsl:message>
    <xsl:result-document href="{$file}" format="packageInfo">
      <html>
        <head>
          <title>Package Information</title>
          <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        </head>
        <body>&cr;
          <xsl:apply-templates select="." mode="desc" />
        </body>
      </html>
    </xsl:result-document>
      <xsl:variable name="file" select="concat($output_root,'/',$dir,'/package-info.java')"/>
      <!-- open file for this class -->
      <xsl:message >Writing package info file <xsl:value-of select="$file"/></xsl:message>
      <xsl:variable name="ns" select="$mapping/map:mappedModels/model[name=current()/ancestor-or-self::vo-dml:model/name]/xml-targetnamespace"/>
      <xsl:result-document href="{$file}" >
@javax.xml.bind.annotation.XmlSchema(namespace = "<xsl:value-of select="$ns"/>", xmlns = {
@javax.xml.bind.annotation.XmlNs(namespaceURI = "<xsl:value-of select="$ns"/>", prefix = "<xsl:value-of select="$ns/@prefix"/>")
  })
package <xsl:value-of select="$path"/>;

      </xsl:result-document>

  </xsl:template>


  <xsl:template name="TypeImport">
    <xsl:param name="vodml-ref"/>
 <!--
        <xsl:message>Looking for vodml-ref <xsl:value-of select="$vodml-ref"/></xsl:message>
 -->    
    <xsl:variable name="vodml-id" select="substring-after($vodml-ref,':')"/>
    <xsl:variable name="mappedtype" select="vf:findmapping($vodml-ref)" />

<!--     <xsl:message>TypeImprt: mappedtype =  "<xsl:value-of select="$mappedtype"/>"</xsl:message> -->
   <xsl:choose>
      <xsl:when test="$mappedtype != ''">
<!--          <xsl:message>TypeImprt: found mapping for <xsl:value-of select="$vodml-ref"/>, no import necessary</xsl:message> -->
      </xsl:when>
      <xsl:otherwise>
<!--          <xsl:message>TypeImprt: building import for <xsl:value-of select="$vodml-ref" /></xsl:message> -->
         <xsl:variable name="themodel" as="element()">
            <xsl:call-template name="getmodel">
               <xsl:with-param name="vodml-ref" select="$vodml-ref" />
            </xsl:call-template>
         </xsl:variable>
<!--          <xsl:message>TypeImprt: looking for <xsl:value-of select="$vodml-ref" /> in model = <xsl:value-of select="$themodel/name" /></xsl:message> -->
         <xsl:variable name="type" as="element()" select="$themodel//*[vodml-id = $vodml-id]" />
         <xsl:variable name="path">
            <xsl:call-template name="package-path">
               <xsl:with-param name="model" select="$themodel" />
               <xsl:with-param name="packageid">
                  <xsl:value-of select="$type/../vodml-id" />
               </xsl:with-param>
               <xsl:with-param name="delimiter">.</xsl:with-param>
            </xsl:call-template>
         </xsl:variable>
         <xsl:variable name="root" select="$mapping/map:mappedModels/model[name=$themodel/name]/java-package" />
         import <xsl:value-of select="$root" /><xsl:if test="$path !=''">.</xsl:if><xsl:value-of select="$path" />.<xsl:value-of select="$type/name" />;
      </xsl:otherwise>
   </xsl:choose>
  </xsl:template> 
  
  <xsl:template match="objectType|dataType|enumeration|primitiveType" mode="path">
    <xsl:variable name="modelname" select="./ancestor::vo-dml:model/name"/>
    
    <xsl:message >Looking for path for <xsl:value-of select="vodml-id"/> in model <xsl:value-of select="$modelname"/>
    </xsl:message>

     <xsl:variable name="path" >
      <xsl:call-template name="package-path">
        <xsl:with-param name="model" select="./ancestor::vo-dml:model"/>
        <xsl:with-param name="packageid"><xsl:value-of select="./../vodml-id"/></xsl:with-param>
        <xsl:with-param name="delimiter">.</xsl:with-param>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="root" select="$mapping/map:mappedModels/model[name=$modelname]/java-package"/>
    <xsl:value-of select="$root"/><xsl:if test="$path !=''">.</xsl:if><xsl:value-of select="$path"/>.<xsl:value-of select="name"/>
  </xsl:template>
  
  



 

  <!-- find a java package path towards the type identified with the name -->
  <xsl:template name="fullpath">
    <xsl:param name="vodml-ref"/>
     <!-- <xsl:message >Finding full path for <xsl:value-of select="$vodml-ref"/></xsl:message> -->
    
    <xsl:variable name="themodel" as="element()">
        <xsl:call-template name="getmodel"><xsl:with-param name="vodml-ref" select="$vodml-ref"/></xsl:call-template>
    </xsl:variable>

    <xsl:variable name="root" select="$mapping/map:mappedModels/model[name=$themodel/name]/java-package"/>

    <xsl:variable name="vodmlid" select="substring-after($vodml-ref,':' )"/>    
    <xsl:variable name="path">
    <xsl:for-each select="$themodel//*[vodml-id=$vodmlid]/ancestor-or-self::*[name() != 'vo-dml:model']">
       <xsl:value-of select="./name"/>
       <xsl:if test="position() != last()">
       <xsl:text>.</xsl:text>
       </xsl:if>
    </xsl:for-each>
    </xsl:variable>
    <xsl:value-of select="concat($root,'.',$path)"/>

  </xsl:template>
 <xsl:template name="vodmlAnnotation">
 @org.ivoa.vodml.annotation.VoDml(ref="<xsl:value-of select='concat(ancestor::vo-dml:model/name,":",vodml-id)'/>", type=org.ivoa.vodml.annotation.VodmlType.<xsl:value-of select='name(.)'/>)
 </xsl:template>


</xsl:stylesheet>
