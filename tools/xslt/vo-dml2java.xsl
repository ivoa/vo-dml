<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE stylesheet [
<!ENTITY cr "<xsl:text>
</xsl:text>">
<!ENTITY bl "<xsl:text> </xsl:text>">
]>

<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                xmlns:vo-dml="http://www.ivoa.net/xml/VODML/v1"
                xmlns:vf="http://www.ivoa.net/xml/VODML/functions"
                xmlns:exsl="http://exslt.org/common"
                xmlns:map="http://www.ivoa.net/xml/vodml-binding/v0.9"
                xmlns:xsd="http://www.w3.org/2001/XMLSchema"
                extension-element-prefixes="exsl"
                exclude-result-prefixes="map" 
                >
<!-- 
  This XSLT script transforms a data model in VO-DML/XML representation to 
  Purely Ordinary Java Classes.
  
  Only defines fields for components.
  Only argumentless constructor.
  
  Java 1.8 is required by these two libraries.
  
  Gerard Lemson (mpa)/Laurent Bourges (grenoble), Paul Harrison (JBO)
-->

  <xsl:import href="common-binding.xsl"/>
  <xsl:include href="jaxb.xsl"/>
  <xsl:include href="jpa.xsl"/>
 
 

  <xsl:output method="text" encoding="UTF-8" indent="yes" />
  <xsl:output name="packageInfo" method="html" encoding="UTF-8" doctype-public="-//W3C//DTD HTML 4.01 Transitional//EN"/>
    <xsl:output name="packageInfoJ" method="text" encoding="UTF-8"/>

  <xsl:strip-space elements="*" />


  <xsl:param name="lastModified"/>
  <xsl:param name="lastModifiedText"/>
  <xsl:param name="output_root" />
  <xsl:param name="vo-dml_package" select="'org.ivoa.vodml.model'"/>
  <xsl:param name="binding"/>
  <xsl:variable name="vodmlauthor" select="'@author generated by https://github.com/ivoa/vo-dml tools'"/>
    <xsl:variable name="lt">&lt;</xsl:variable>
    <xsl:variable name="gt">&gt;</xsl:variable>
  <xsl:variable name="mapping">
  <xsl:message>setting mapping</xsl:message>
    <map:mappedModels>
      <xsl:for-each select="tokenize($binding,',')">
      <xsl:message><xsl:value-of select="."/></xsl:message>
          <xsl:copy-of
                  select="document(normalize-space(.))/map:mappedModels/model" />
      </xsl:for-each>
    </map:mappedModels>
  </xsl:variable>
 
 <!-- load all models at start -->
  <xsl:variable name="models">
     <xsl:message>setting models</xsl:message>
      <xsl:for-each select="$mapping/map:mappedModels/model">
         <xsl:choose>
            <xsl:when test="file"> <!-- prefer local file for reading defn -->
            <xsl:message>opening file <xsl:value-of select="file"/></xsl:message>
               <xsl:copy-of
                  select="document(file)/vo-dml:model" />
            </xsl:when>
            <xsl:when test="url">
               <xsl:copy-of
                  select="document(url)/vo-dml:model" />
            </xsl:when>
            <xsl:otherwise>
               <xsl:message>Model <xsl:value-of select="vodml-id" />has neither url nor file, hence no artifacts will be generated.</xsl:message>
            </xsl:otherwise>
         </xsl:choose>
      </xsl:for-each>
   </xsl:variable>
 

  <!-- next could be parameters -->


  <!-- main pattern : processes for root node model -->
  <xsl:template match="/">
  <xsl:message >Generating Java - considering models <xsl:value-of select="string-join($models/vo-dml:model/name,' and ')" /></xsl:message>
  <xsl:apply-templates/>
 </xsl:template>

  <!-- model pattern : generates gen-log and processes nodes package and generates the ModelVersion class and persistence.xml -->
  <xsl:template match="vo-dml:model">
    <xsl:message>
-------------------------------------------------------------------------------------------------------
-- Generating Java code for model <xsl:value-of select="name"/> [<xsl:value-of select="title"/>].
-- last modification date of the model <xsl:value-of select="lastModified"/>
-------------------------------------------------------------------------------------------------------
    </xsl:message>

    <xsl:variable name="prefix" select="name"/>
      <xsl:if test="not($mapping/map:mappedModels/model[name=$prefix])">
          <xsl:message terminate="yes">
              There is no binding for model <xsl:value-of select="$prefix"/>
          &cr;
          </xsl:message>
      </xsl:if>
      <xsl:variable name="root_package" select="$mapping/map:mappedModels/model[name=$prefix]/java-package"/>
      <xsl:variable name="root_package_dir" select="replace($root_package,'[.]','/')"/>

      <!--
          <xsl:message>root_package = <xsl:value-of select="$root_package"/></xsl:message>
          <xsl:message>root_package_dir = <xsl:value-of select="$root_package_dir"/></xsl:message>
       -->

      <!-- don't do model factory for now
    <xsl:apply-templates select="." mode="modelFactory">
      <xsl:with-param name="root_package" select="$root_package"/>
      <xsl:with-param name="root_package_dir" select="$root_package_dir"/>
    </xsl:apply-templates>
    -->

    <xsl:apply-templates select="." mode="content">
      <xsl:with-param name="dir" select="$root_package_dir"/>
      <xsl:with-param name="path" select="$root_package"/>
    </xsl:apply-templates>

      <xsl:apply-templates select="." mode="jpaConfig" />

  </xsl:template>  




  <xsl:template match="vo-dml:model|package" mode="content">
    <xsl:param name="dir"/>
    <xsl:param name="path"/>

    <xsl:variable name="newdir">
      <xsl:choose>
        <xsl:when test="$dir and ./name() = 'package'">
          <xsl:value-of select="concat($dir,'/',name)"/>
        </xsl:when>
        <xsl:when test="$dir and ./name() = 'vo-dml:model'">
          <xsl:value-of select="$dir"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="name"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
   
    <xsl:variable name="newpath">
      <xsl:choose>
        <xsl:when test="$path and ./name() = 'package'">
          <xsl:value-of select="concat($path,'.',name)"/>
        </xsl:when>
        <xsl:when test="$path and ./name() = 'vo-dml:model'">
          <xsl:value-of select="$path"/>
        </xsl:when>
        <xsl:otherwise>
          <xsl:value-of select="name"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
   
    <xsl:message>package = <xsl:value-of select="$newpath"></xsl:value-of></xsl:message>

      <xsl:apply-templates select="." mode="packageDesc">
          <xsl:with-param name="dir" select="$newdir"/>
          <xsl:with-param name="path" select="$newpath"/>
      </xsl:apply-templates>

      <xsl:apply-templates select="." mode="jaxb.index">
          <xsl:with-param name="dir" select="$newdir"/>
      </xsl:apply-templates>




      <xsl:apply-templates select="objectType|dataType|enumeration|primitiveType" mode="file">
      <xsl:with-param name="dir" select="$newdir"/>
      <xsl:with-param name="path" select="$newpath"/>
    </xsl:apply-templates>

    <xsl:apply-templates select="package" mode="content">
      <xsl:with-param name="dir" select="$newdir"/>
      <xsl:with-param name="path" select="$newpath"/>
    </xsl:apply-templates>

  </xsl:template>


  <xsl:template match="objectType|dataType|enumeration|primitiveType" mode="file">
    <xsl:param name="dir"/>
    <xsl:param name="path"/>

    <xsl:variable name="vodml-id" select="vodml-id" />
    <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
    <xsl:variable name="mappedtype">
      <xsl:call-template name="findmappingInThisModel">
        <xsl:with-param name="modelname" select="./ancestor::vo-dml:model/name"/>
        <xsl:with-param name="vodml-id" select="$vodml-id"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:choose>
    <xsl:when test="not($mappedtype) or $mappedtype = ''" >
      <xsl:variable name="file" select="concat($output_root, '/', $dir, '/', name, '.java')"/>

    <!-- open file for this class -->
      <xsl:message >Writing to Class file <xsl:value-of select="$file"/> base=<xsl:value-of select="vf:baseTypes($vodml-ref)/name"/> haschildren=<xsl:value-of select="vf:hasChildren($vodml-ref)"/></xsl:message>
      
      <xsl:result-document href="{$file}">
        <xsl:apply-templates select="." mode="class">
          <xsl:with-param name="path" select="$path"/>
        </xsl:apply-templates>
      </xsl:result-document>
    </xsl:when>
      <xsl:otherwise>
       <xsl:message>1) Mapped type for <xsl:value-of select="$vodml-ref"/> = '<xsl:value-of select="$mappedtype"/>'</xsl:message>
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>

    <xsl:template match="objectType|dataType|primitiveType|enumeration" mode="typeimports">
        <xsl:variable name="vodmlref" select="vf:asvodmlref(.)"/>
        <xsl:variable name="modelp" select="concat(./ancestor::vo-dml:model/name,':', string-join(reverse(ancestor::package/name),'***'))"/>
        <xsl:for-each select="distinct-values(extends/vodml-ref|attribute/datatype/vodml-ref|reference/datatype/vodml-ref|composition/datatype/vodml-ref)" >
<!--           <xsl:message>import <xsl:value-of select="concat(.,' -> ',$modelp, ' ', not(starts-with(.,$modelp)))"/> </xsl:message>-->
            <xsl:if test="not(starts-with(.,$modelp))">
                <xsl:call-template name="TypeImport">
                    <xsl:with-param name="vodml-ref" select="."/>
                </xsl:call-template>
            </xsl:if>
        </xsl:for-each>
    </xsl:template>

    <xsl:template name="allMembers">
        <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
        <xsl:variable name="supers" select="(.,vf:baseTypes($vodml-ref))"/>
        <xsl:message>allmembers = <xsl:value-of select="$vodml-ref"/> supers=<xsl:value-of select="$supers/name"/></xsl:message>
        <xsl:copy-of select="$supers/attribute,$supers/composition,$supers/reference" /><!-- note that this cannot be sequence or different things happen with for-each and just $x/y expressions in terms of ordering -->
    </xsl:template>

    <xsl:template match="objectType|dataType" mode="builder">
        <xsl:variable name="members" as="element()*">
            <xsl:call-template name="allMembers"/>
        </xsl:variable>
        public static class <xsl:value-of select="name"/>Builder {
           <xsl:for-each select="$members">
           /**
            * <xsl:apply-templates select="." mode="desc"/>
           */
           public <xsl:apply-templates select="." mode="paramDecl"/>;
           </xsl:for-each>

           public <xsl:value-of select="name"/>Builder with (java.util.function.Consumer &lt;<xsl:value-of select="name"/>Builder&gt; f)
           {
             f.accept(this);
             return this;
           }
           public <xsl:value-of select="name"/> create()
           {
             return new <xsl:value-of select="name"/> (
             <xsl:value-of select="string-join($members/name, ',')" />
             );
           }
         }
         public static <xsl:value-of select="name"/>&bl;builder (java.util.function.Consumer &lt;<xsl:value-of select="name"/>Builder&gt; f)
         {
             return new <xsl:value-of select="name"/>Builder().with(f).create();
         }
    </xsl:template>

    <!-- generate a all member constructor
      The general tactic is to look for all supertype members and initialize them in the one constructor, because it
       is easier to generate than calling super constructors with their appropriate parameters.
    -->
    <xsl:template match="objectType|dataType" mode="constructor">
        <xsl:variable name="members" as="element()*"  >
            <xsl:call-template name="allMembers" />
        </xsl:variable>
        <xsl:variable name="decls" as="xsd:string*">
                <xsl:for-each select="$members">
                <xsl:apply-templates select="." mode="paramDecl"/>
                </xsl:for-each>
        </xsl:variable>
        <xsl:if test="count($members) > 0">
        /**
        * full parameter constructor.
        */
        public  <xsl:value-of select="name"/> (
          <xsl:value-of select="string-join($decls,',')"/>
        )
        {
           <xsl:for-each select="$members/name">
               this.<xsl:value-of select="."/> = <xsl:value-of select="."/>;
           </xsl:for-each>
        }
        </xsl:if>
    </xsl:template>

  <xsl:template match="attribute|composition|reference" mode="paramDecl">
      <xsl:variable name="type"><xsl:call-template name="JavaType"><xsl:with-param name="vodml-ref" select="datatype/vodml-ref"/></xsl:call-template></xsl:variable>
      <xsl:choose>
          <xsl:when test="name()='composition'"><!-- FIXME should not always be a list -->
              <xsl:value-of select="concat('java.util.List',$lt,$type,$gt, ' ',name)" />
          </xsl:when>
          <xsl:otherwise>
              <xsl:value-of select="concat($type, ' ',name)" />
          </xsl:otherwise>
      </xsl:choose>

  </xsl:template>

    <!-- template class creates a java class (JPA compliant) for UML object & data types -->
  <xsl:template match="objectType|dataType" mode="class">
    <xsl:param name="path"/>
    <xsl:variable name="vodml-ref"><xsl:apply-templates select="vodml-id" mode="asvodml-ref"/></xsl:variable>
  package <xsl:value-of select="$path"/>;

    <!-- imports -->
    <xsl:if test="composition">
      import java.util.List;
      import java.util.ArrayList;
    </xsl:if>
    <xsl:apply-templates select="." mode="typeimports"/>
/**
* <xsl:apply-templates select="." mode="desc" />
*
* <xsl:value-of select="name()"/>: &bl;<xsl:value-of select="name" />
*
* <xsl:value-of select="$vodmlauthor"/>
*/
    <xsl:apply-templates select="." mode="JPAAnnotation"/>
    <xsl:apply-templates select="." mode="JAXBAnnotation"/>
    <xsl:call-template name="vodmlAnnotation"/>
       public&bl;<xsl:if test="@abstract='true'">abstract</xsl:if>&bl;class <xsl:value-of select="name"/>&bl;
      <xsl:if test="extends">extends <xsl:call-template name="JavaType"><xsl:with-param name="vodml-ref" select="extends/vodml-ref"/></xsl:call-template></xsl:if>
    &bl;{
      <xsl:if test="local-name() eq 'objectType' and not (extends)" >
          /**
          * inserted database key
          */
          <xsl:choose>
              <xsl:when test="vf:referredTo($vodml-ref)"> <!-- TODO - would be nice to actually use natural key if it exists - see https://github.com/ivoa/vo-dml/issues/4 -->
          @javax.xml.bind.annotation.XmlID
          @javax.persistence.Id
          @javax.persistence.GeneratedValue
          protected String id;

          /**
          * @return the id
          */
          public String getId() {
          return id;
          }
              </xsl:when>
              <xsl:otherwise>
          @javax.xml.bind.annotation.XmlTransient
          @javax.persistence.Id
          @javax.persistence.GeneratedValue
          protected Long id;

          /**
          * @return the id
          */
          public Long getId() {
          return id;
          }

              </xsl:otherwise>
          </xsl:choose>
      </xsl:if>
<!-- 
      /** serial uid = last modification date of the UML model */
      private static final long serialVersionUID = LAST_MODIFICATION_DATE;
 -->
      <xsl:apply-templates select="attribute" mode="declare" />
      <xsl:apply-templates select="composition" mode="declare" />
      <xsl:apply-templates select="reference" mode="declare" />
      /**
       * Creates a new <xsl:value-of select="name"/>
       */
      public <xsl:value-of select="name"/>() {
        super();
      }
      <xsl:apply-templates select="." mode="constructor"/>

      <xsl:apply-templates select="attribute|reference|composition" mode="getset"/>

      <xsl:if test="not(@abstract)">
      <xsl:apply-templates select="." mode="builder"/>
      </xsl:if>
      
}
  </xsl:template>




  <xsl:template match="enumeration" mode="class">
    <xsl:param name="dir"/>
    <xsl:param name="path"/>
package <xsl:value-of select="$path"/>;

      /**
      * <xsl:apply-templates select="." mode="desc" />
      *
      * Enumeration <xsl:value-of select="name"/> :
      *
      * <xsl:value-of select="$vodmlauthor"/>
      */
      public enum <xsl:value-of select="name"/>&bl;{

        <xsl:apply-templates select="literal"  />

        /** string representation */
        private final String value;

        /**
         * Creates a new <xsl:value-of select="name"/> Enumeration Literal
         *
         * @param v string representation
         */
        <xsl:value-of select="name"/>(final String v) {
            value = v;
        }

        /**
         * Return the string representation of this enum constant (value)
         * @return string representation of this enum constant (value)
         */
        public final String value() {
            return this.value;
        }

        /**
         * Return the string representation of this enum constant (value)
         * @see #value()
         * @return string representation of this enum constant (value)
         */
        @Override
        public final String toString() {
            return value();
        }

        /**
         * Return the <xsl:value-of select="name"/> enum constant corresponding to the given string representation (value)
         *
         * @param v string representation (value)
         *
         * @return <xsl:value-of select="name"/> enum constant
         *
         * @throws IllegalArgumentException if there is no matching enum constant
         */
        public final static <xsl:value-of select="name"/> fromValue(final String v) {
          for (<xsl:value-of select="name"/> c : <xsl:value-of select="name"/>.values()) {
              if (c.value.equals(v)) {
                  return c;
              }
          }
          throw new IllegalArgumentException("<xsl:value-of select="name"/>.fromValue : No enum const for the value : " + v);
        }

      }
  </xsl:template>

  <xsl:template match="primitiveType" mode="class">
    <xsl:param name="path"/>

    <xsl:variable name="valuetype">
      <xsl:choose>
        <xsl:when test="extends">
          <xsl:call-template name="JavaType">
            <xsl:with-param name="vodml-ref" select="extends/vodml-ref"/>
          </xsl:call-template>
        </xsl:when>
        <xsl:otherwise>
        <xsl:value-of select="'Object'"/>
        </xsl:otherwise>
      </xsl:choose>
    </xsl:variable>
package <xsl:value-of select="$path"/>;
        <xsl:apply-templates select="." mode="typeimports" />
<!---->

      /**
      *  <xsl:apply-templates select="." mode="desc" />
      *  PrimitiveType <xsl:value-of select="name"/> :
      *
      *  <xsl:value-of select="$vodmlauthor"/>
      */
      <xsl:call-template name="vodmlAnnotation"/>
      <xsl:apply-templates select="." mode="JPAAnnotation"/>
      <xsl:apply-templates select="." mode="JAXBAnnotation"/>
      public class <xsl:value-of select="name"/>&bl;{

        /** string representation */
        private <xsl:value-of select="$valuetype"/> value;

        /**
         * Creates a new <xsl:value-of select="name"/> Primitive Type instance, wrapping a base type.
         *
         * @param v 
         */
        public <xsl:value-of select="name"/>(final <xsl:value-of select="$valuetype"/> v) {
            this.value = v;
        }
        /**
         * no arg constructor.
         */
        protected <xsl:value-of select="name"/>() {}

        /**
         * Return the representation of this primitive (value)
         * @return string representation of this primitive( value)
         */
        public final <xsl:value-of select="$valuetype"/> value() {
            return this.value;
        }

        /**
         * Return the string representation of this primitive value
         * @see #value()
         * @return string representation of this primitive
         */
        @Override
        public final String toString() {
            return value().toString();
        }
              

      }
  </xsl:template>


  <xsl:template match="attribute" mode="declare">
    <xsl:variable name="type"><xsl:call-template name="JavaType"><xsl:with-param name="vodml-ref" select="datatype/vodml-ref"/></xsl:call-template></xsl:variable>
    /** 
    * <xsl:apply-templates select="." mode="desc" /> : Attribute <xsl:value-of select="name"/> :
    *
    */
    <xsl:call-template name="vodmlAnnotation"/>
    <xsl:apply-templates select="." mode="JPAAnnotation"/>
    <xsl:apply-templates select="." mode="JAXBAnnotation"/>
    protected <xsl:value-of select="$type"/><xsl:if test="contains(multiplicity,'*')">[]</xsl:if>&bl;<xsl:value-of select="name"/>;
  </xsl:template>




  <xsl:template match="attribute" mode="getset">
    <xsl:variable name="type"><xsl:call-template name="JavaType"><xsl:with-param name="vodml-ref" select="datatype/vodml-ref"/></xsl:call-template></xsl:variable>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    /**
    * Returns <xsl:value-of select="name"/> Attribute
    * @return <xsl:value-of select="name"/> Attribute
    */
    public <xsl:value-of select="$type"/><xsl:if test="contains(multiplicity,'*')">[]</xsl:if>&bl;get<xsl:value-of select="$name"/>() {
    return this.<xsl:value-of select="name"/>;
    }
    /**
    * Defines <xsl:value-of select="name"/> Attribute
    * @param p<xsl:value-of select="$name"/> value to set
    */
    public void set<xsl:value-of select="$name"/>(final <xsl:value-of select="$type"/><xsl:if test="contains(multiplicity,'*')">[]</xsl:if> p<xsl:value-of select="$name"/>) {
    this.<xsl:value-of select="name"/> = p<xsl:value-of select="$name"/>;
    }

      public <xsl:call-template name="JavaType">
      <xsl:with-param name="vodml-ref" select="vf:asvodmlref(parent::*)"/>
       </xsl:call-template> with<xsl:value-of select="$name"/>(final <xsl:value-of select="$type"/><xsl:if test="contains(multiplicity,'*')">[]</xsl:if> p<xsl:value-of select="$name"/>) {
      this.<xsl:value-of select="name"/> = p<xsl:value-of select="$name"/>;
      return this;
      }
<!-- uncomment next if we decide to try out property access for nested embeddables. -->
<!-- 
    <xsl:variable name="datatype" select="key('element',datatype/vodml-ref)"/>
    <xsl:if test="../name() = 'dataType' and name($datatype) = 'dataType'">
      <xsl:apply-templates select="." mode="nestedgetset"/>
    </xsl:if> 
 -->
   </xsl:template>

  <xsl:template match="attribute" mode="setProperty">
    <xsl:variable name="type"><xsl:call-template name="JavaType"><xsl:with-param name="vodml-ref" select="datatype/vodml-ref"/></xsl:call-template></xsl:variable>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
      set<xsl:value-of select="$name"/>((<xsl:value-of select="$type"/><xsl:if test="contains(multiplicity,'*')">[]</xsl:if>)pValue);
      return true;
    }
  </xsl:template>

  <xsl:template match="attribute" mode="setStringProperty">
    <xsl:variable name="type"><xsl:call-template name="JavaType">
    <xsl:with-param name="vodml-ref" select="datatype/vodml-ref"/>
    </xsl:call-template></xsl:variable>
    <xsl:variable name="element" as="element()"><xsl:call-template name="Element4vodml-ref">
    <xsl:with-param name="vodml-ref" select="datatype/vodml-ref"/>
    </xsl:call-template></xsl:variable>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:if test="$element/name() = 'enumeration' or $element/name() = 'primitiveType'">
    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
     <xsl:choose>
       <xsl:when test="$element/name() = 'enumeration'">
             set<xsl:value-of select="$name"/>(<xsl:value-of select="$type"/>.fromValue(pValue));
       </xsl:when>
       <xsl:otherwise>
      set<xsl:value-of select="$name"/>(new <xsl:value-of select="$type"/>(pValue));
       </xsl:otherwise>
     </xsl:choose>
      return true;
    }
    </xsl:if>
  </xsl:template>



  <xsl:template match="composition" mode="declare">
      <!-- FIXME a composition as a list allows ? multiplicity to be broken -->
    <xsl:variable name="type"><xsl:call-template name="JavaType"><xsl:with-param name="vodml-ref" select="datatype/vodml-ref"/></xsl:call-template></xsl:variable>
    <xsl:if test="not(subsets)">
    <xsl:call-template name="vodmlAnnotation"/>
    
    /** 
    * <xsl:apply-templates select="." mode="desc" />
    * composition <xsl:value-of select="name"/> :
    * (
    * Multiplicity : <xsl:value-of select="multiplicity"/>
    * )
    */
    protected List&lt;<xsl:value-of select="$type"/>&gt;&bl;<xsl:value-of select="name"/> = null;
    </xsl:if>
  </xsl:template>



<!-- define methods for getting/setting and adding to composition -->
  <xsl:template match="composition" mode="getset">
    <xsl:variable name="type"><xsl:call-template name="JavaType"><xsl:with-param name="vodml-ref" select="datatype/vodml-ref"/></xsl:call-template></xsl:variable>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="datatype" select="substring-after(datatype/vodml-ref,':')"/>
    
    <xsl:if test="not(subsets)">
    /**
    * Returns <xsl:value-of select="name"/> composition
    * @return <xsl:value-of select="name"/> composition
    */
    public List&lt;<xsl:value-of select="$type"/>&gt;&bl;get<xsl:value-of select="$name"/>() {
    return this.<xsl:value-of select="name"/>;
    }
    /**
    * Defines <xsl:value-of select="name"/> composition
    * @param p<xsl:value-of select="$name"/> composition to set
    */
    public void set<xsl:value-of select="$name"/>(final List&lt;<xsl:value-of select="$type"/>&gt; p<xsl:value-of select="$name"/>) {
    this.<xsl:value-of select="name"/> = p<xsl:value-of select="$name"/>;
    }
    /**
    * Add a <xsl:value-of select="$type"/> to the composition
    * Note: if the composition is big, set the rank value before adding the item to the composition
    * @param p<xsl:value-of select="$type"/>&bl;<xsl:value-of select="$type"/> to add
    */
    public void add<xsl:value-of select="$name"/>(final <xsl:value-of select="$type"/> p<xsl:value-of select="$type"/>) {
      if(this.<xsl:value-of select="name"/> == null) {
        this.<xsl:value-of select="name"/> = new ArrayList&lt;&gt;();
      }
      this.<xsl:value-of select="name"/>.add(p<xsl:value-of select="$type"/>);
    }
    </xsl:if>
  </xsl:template>

  <xsl:template match="composition" mode="add2composition">
    <xsl:variable name="type"><xsl:call-template name="JavaType"><xsl:with-param name="vodml-ref" select="datatype/vodml-ref"/></xsl:call-template></xsl:variable>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
      add<xsl:value-of select="$name"/>((<xsl:value-of select="$type"/>)object);
      return true;
    }
  </xsl:template>



  <xsl:template match="reference" mode="declare">
  <xsl:if test="not(subsets)">
    <xsl:variable name="type"><xsl:call-template name="JavaType"><xsl:with-param name="vodml-ref" select="datatype/vodml-ref"/></xsl:call-template></xsl:variable>
    /** 
    * ReferenceObject <xsl:value-of select="name"/> :
    * <xsl:apply-templates select="." mode="desc" />
    * (
    * Multiplicity : <xsl:value-of select="multiplicity"/>
    * )
    */
    <xsl:apply-templates select="." mode="JPAAnnotation"/>
    <xsl:apply-templates select="." mode="JAXBAnnotation"/>
    protected <xsl:value-of select="$type"/>&bl;<xsl:value-of select="name"/> = null;
    </xsl:if>
  </xsl:template>




  <xsl:template match="reference" mode="getset">
    <xsl:variable name="type">
      <xsl:call-template name="JavaType">
        <xsl:with-param name="vodml-ref" select="datatype/vodml-ref"/>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    /**
    * Returns <xsl:value-of select="name"/> Reference<br/>
    * @return <xsl:value-of select="name"/> Reference
    */
    public <xsl:value-of select="$type"/>&bl;get<xsl:value-of select="$name"/>() {
    <xsl:choose>
      <xsl:when test="subsets">
        return (<xsl:value-of select="$type"/>)super.get<xsl:value-of select="$name"/>();
      </xsl:when>
      <xsl:otherwise>
        return this.<xsl:value-of select="name"/>;
      </xsl:otherwise>
    </xsl:choose>
    }
    /**
    * Defines <xsl:value-of select="name"/> Reference
    * @param p<xsl:value-of select="$name"/> reference to set
    */
    public void set<xsl:value-of select="$name"/>(final <xsl:value-of select="$type"/> p<xsl:value-of select="$name"/>) {
    <xsl:choose>
      <xsl:when test="subsets">
        super.set<xsl:value-of select="$name"/>(p<xsl:value-of select="$name"/>);
      </xsl:when>
      <xsl:otherwise>
        this.<xsl:value-of select="name"/> = p<xsl:value-of select="$name"/>;
      </xsl:otherwise>
    </xsl:choose>
    }
  </xsl:template>




  <xsl:template match="reference" mode="setProperty">
    <xsl:variable name="type"><xsl:call-template name="JavaType"><xsl:with-param name="vodml-ref" select="datatype/vodml-ref"/></xsl:call-template></xsl:variable>
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>

    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
      if(pValue instanceof ReferenceObject)
        set<xsl:value-of select="$name"/>((ReferenceObject)pValue);
      else 
        set<xsl:value-of select="$name"/>((<xsl:value-of select="$type"/>)pValue);
      return true;
    }
  </xsl:template>

  <xsl:template match="literal" >
    /** 
    * Value <xsl:value-of select="name"/> :
    * 
    * <xsl:apply-templates select="." mode="desc" />
    */
    <xsl:variable name="up">
      <xsl:call-template name="constant">
        <xsl:with-param name="text" select="name"/>
      </xsl:call-template>
    </xsl:variable>

    <xsl:value-of select="$up"/>("<xsl:value-of select="name"/>")
    <xsl:choose>
      <xsl:when test="position() != last()"><xsl:text>,</xsl:text></xsl:when>
      <xsl:otherwise><xsl:text>;</xsl:text></xsl:otherwise>
    </xsl:choose>
    &cr;
  </xsl:template>


  <xsl:template match="attribute|reference|composition" mode="getProperty">
    <xsl:variable name="name">
      <xsl:call-template name="upperFirst">
        <xsl:with-param name="val" select="name"/>
      </xsl:call-template>
    </xsl:variable>
    if ("<xsl:apply-templates select="vodml-id" mode="asvodml-ref"/>".equals(vodmlRef)) {
      return get<xsl:value-of select="$name"/>();
    }
  </xsl:template>




  <xsl:template match="*" mode="desc">
    <xsl:choose>
      <xsl:when test="count(description) > 0 and normalize-space(description) != 'TODO : Missing description : please, update your UML model asap.'">
          <xsl:value-of select="description" disable-output-escaping="yes"/>
          <xsl:if test="not(ends-with(normalize-space(description/text()), '.'))">
              <xsl:value-of select="'.'"/>
          </xsl:if>
      </xsl:when>
      <xsl:otherwise>
<!--       <xsl:message >TODO : <xsl:value-of select="name"/> Missing description : please, update your VO-DML model asap.</xsl:message> -->
      </xsl:otherwise>
    </xsl:choose>
  </xsl:template>  




  <!-- specific documents --> 

  <!-- ModelVersion.java -->
  <xsl:template match="vo-dml:model" mode="modelFactory">
    <xsl:param name="root_package"/>
    <xsl:param name="root_package_dir"/>
    <xsl:variable name="file" select="concat($output_root,'/', $root_package_dir,'/','ModelFactory.java')"/>
    <!-- open file for this class -->
    <xsl:message >Writing Factory file <xsl:value-of select="$file"/></xsl:message>
    <xsl:result-document href="{$file}">package <xsl:value-of select="$root_package"/>;
      <xsl:if test="descendant-or-self::objectType|descendant-or-self::dataType">
      import <xsl:value-of select="$vo-dml_package"/>.StructuredObject;
      </xsl:if>
      /**
      * Factory class for model <xsl:value-of select="name"/>.
      *
      * <xsl:apply-templates select="." mode="desc" />
      *
      * <xsl:value-of select="$vodmlauthor"/>
      */
      public class ModelFactory extends <xsl:value-of select="$vo-dml_package"/>.ModelFactory { 

        /** last modification date of the VODML model */
        public final static String LAST_MODIFICATION_DATE = "<xsl:value-of select="lastModified"/>";

        <xsl:if test="descendant-or-self::objectType|descendant-or-self::dataType">
        @Override
        public StructuredObject newStructuredObject(String vodmlRef)
        {
          if(vodmlRef == null)
            return null;
          <xsl:for-each select="descendant-or-self::objectType|descendant-or-self::dataType" >
          <xsl:if test="not(@abstract = 'true')">
            <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
            <xsl:variable name="type">
              <xsl:call-template name="JavaType">
                <xsl:with-param name="vodml-ref" select="$vodml-ref"/>
                <xsl:with-param name="fullpath" select="'true'"/>
              </xsl:call-template>
            </xsl:variable>
           else if("<xsl:value-of select="$vodml-ref"/>".equals(vodmlRef))
            return new <xsl:value-of select="$type"/>();
            </xsl:if>
          </xsl:for-each>  
          return null;
        }
        </xsl:if>
        <xsl:if test="descendant-or-self::enumeration">
        @Override
        public Object newEnumeratedValue(String vodmlRef, String value)
        {
          if(vodmlRef == null)
            return null;
          <xsl:for-each select="descendant-or-self::enumeration">
            <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
          <xsl:if test="not(@abstract = 'true')">
          else if("<xsl:value-of select="$vodml-ref"/>".equals(vodmlRef))
            return <xsl:apply-templates select="." mode="path"/>.fromValue(value);
            </xsl:if>
          </xsl:for-each>  
          return null;
        }
        </xsl:if>
        <xsl:if test="descendant-or-self::primitiveType">
        @Override
        public Object newPrimitiveValue(String vodmlRef, String value)
        {
          if(vodmlRef == null)
            return null;
          <xsl:for-each select="descendant-or-self::primitiveType">
            <xsl:variable name="vodml-ref" select="vf:asvodmlref(.)"/>
            <xsl:variable name="type">
              <xsl:call-template name="JavaType">
                <xsl:with-param name="vodml-ref" select="$vodml-ref"/>
                <xsl:with-param name="fullpath" select="'true'"/>
              </xsl:call-template>
            </xsl:variable>
          else if("<xsl:value-of select="$vodml-ref"/>".equals(vodmlRef))
            return new <xsl:value-of select="$type"/>(value);
          </xsl:for-each>  
          return null;
        }
        </xsl:if>
      }
    </xsl:result-document>
  </xsl:template>




  <!-- package.html -->
  <xsl:template match="vo-dml:model|package" mode="packageDesc">
    <xsl:param name="dir"/>
      <xsl:param name="path"/>
    <xsl:variable name="file" select="concat($output_root,'/',$dir,'/package.html')"/>
    <!-- open file for this class -->
    <xsl:message >Writing package file <xsl:value-of select="$file"/></xsl:message>
    <xsl:result-document href="{$file}" format="packageInfo">
      <html>
        <head>
          <title>Package Information</title>
          <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        </head>
        <body>&cr;
          <xsl:apply-templates select="." mode="desc" />
        </body>
      </html>
    </xsl:result-document>
      <xsl:variable name="file" select="concat($output_root,'/',$dir,'/package-info.java')"/>
      <!-- open file for this class -->
      <xsl:message >Writing package info file <xsl:value-of select="$file"/></xsl:message>
      <xsl:variable name="ns" select="$mapping/map:mappedModels/model[name=current()/ancestor-or-self::vo-dml:model/name]/xml-targetnamespace"/>
      <xsl:result-document href="{$file}" >
@javax.xml.bind.annotation.XmlSchema(namespace = "<xsl:value-of select="$ns"/>", xmlns = {
@javax.xml.bind.annotation.XmlNs(namespaceURI = "<xsl:value-of select="$ns"/>", prefix = "<xsl:value-of select="$ns/@tns"/>")
  })
package <xsl:value-of select="$path"/>;

      </xsl:result-document>

  </xsl:template>


  <xsl:template name="TypeImport">
    <xsl:param name="vodml-ref"/>
 <!--
        <xsl:message>Looking for vodml-ref <xsl:value-of select="$vodml-ref"/></xsl:message>
 -->    
    <xsl:variable name="vodml-id" select="substring-after($vodml-ref,':')"/>
    <xsl:variable name="mappedtype">
      <xsl:call-template name="findmapping">
        <xsl:with-param name="vodml-ref" select="$vodml-ref"/>
      </xsl:call-template>
    </xsl:variable>
<!--     <xsl:message>TypeImprt: mappedtype =  "<xsl:value-of select="$mappedtype"/>"</xsl:message> -->
   <xsl:choose>
      <xsl:when test="$mappedtype != ''">
<!--          <xsl:message>TypeImprt: found mapping for <xsl:value-of select="$vodml-ref"/>, no import necessary</xsl:message> -->
      </xsl:when>
      <xsl:otherwise>
<!--          <xsl:message>TypeImprt: building import for <xsl:value-of select="$vodml-ref" /></xsl:message> -->
         <xsl:variable name="themodel" as="element()">
            <xsl:call-template name="getmodel">
               <xsl:with-param name="vodml-ref" select="$vodml-ref" />
            </xsl:call-template>
         </xsl:variable>
<!--          <xsl:message>TypeImprt: looking for <xsl:value-of select="$vodml-ref" /> in model = <xsl:value-of select="$themodel/name" /></xsl:message> -->
         <xsl:variable name="type" as="element()" select="$themodel//*[vodml-id = $vodml-id]" />
         <xsl:variable name="path">
            <xsl:call-template name="package-path">
               <xsl:with-param name="model" select="$themodel" />
               <xsl:with-param name="packageid">
                  <xsl:value-of select="$type/../vodml-id" />
               </xsl:with-param>
               <xsl:with-param name="delimiter">.</xsl:with-param>
            </xsl:call-template>
         </xsl:variable>
         <xsl:variable name="root" select="$mapping/map:mappedModels/model[name=$themodel/name]/java-package" />
         import <xsl:value-of select="$root" /><xsl:if test="$path !=''">.</xsl:if><xsl:value-of select="$path" />.<xsl:value-of select="$type/name" />;
      </xsl:otherwise>
   </xsl:choose>
  </xsl:template> 
  
  <xsl:template match="objectType|dataType|enumeration|primitiveType" mode="path">
    <xsl:variable name="modelname" select="./ancestor::vo-dml:model/name"/>
    
    <xsl:message >Looking for path for <xsl:value-of select="vodml-id"/> in model <xsl:value-of select="$modelname"/>
    </xsl:message>

     <xsl:variable name="path" >
      <xsl:call-template name="package-path">
        <xsl:with-param name="model" select="./ancestor::vo-dml:model"/>
        <xsl:with-param name="packageid"><xsl:value-of select="./../vodml-id"/></xsl:with-param>
        <xsl:with-param name="delimiter">.</xsl:with-param>
      </xsl:call-template>
    </xsl:variable>
    <xsl:variable name="root" select="$mapping/map:mappedModels/model[name=$modelname]/java-package"/>
    <xsl:value-of select="$root"/><xsl:if test="$path !=''">.</xsl:if><xsl:value-of select="$path"/>.<xsl:value-of select="name"/>
  </xsl:template>
  
  



 
  <!-- Find a mapping for the given vodml-id, in the provided model -->
  <xsl:template name="findmappingInThisModel">
    <xsl:param name="modelname"/>
    <xsl:param name="vodml-id"/>
        <xsl:value-of select="$mapping/map:mappedModels/model[name=$modelname]/type-mapping[vodml-id=$vodml-id]/java-type"/>
  </xsl:template>

  <xsl:template name="findmapping">
    <xsl:param name="vodml-ref"/>
    <xsl:variable name="modelname" select="substring-before($vodml-ref,':')" />
    <xsl:value-of select="$mapping/map:mappedModels/model[name=$modelname]/type-mapping[vodml-id=substring-after($vodml-ref,':')]/java-type"/>
  </xsl:template>

  <!-- find a java package path towards the type identified with the name -->
  <xsl:template name="fullpath">
    <xsl:param name="vodml-ref"/>
     <!-- <xsl:message >Finding full path for <xsl:value-of select="$vodml-ref"/></xsl:message> -->
    
    <xsl:variable name="themodel" as="element()">
        <xsl:call-template name="getmodel"><xsl:with-param name="vodml-ref" select="$vodml-ref"/></xsl:call-template>
    </xsl:variable>

    <xsl:variable name="root" select="$mapping/map:mappedModels/model[name=$themodel/name]/java-package"/>

    <xsl:variable name="vodmlid" select="substring-after($vodml-ref,':' )"/>    
    <xsl:variable name="path">
    <xsl:for-each select="$themodel//*[vodml-id=$vodmlid]/ancestor-or-self::*[name() != 'vo-dml:model']">
       <xsl:value-of select="./name"/>
       <xsl:if test="position() != last()">
       <xsl:text>.</xsl:text>
       </xsl:if>
    </xsl:for-each>
    </xsl:variable>
    <xsl:value-of select="concat($root,'.',$path)"/>

  </xsl:template>
 <xsl:template name="vodmlAnnotation">
 @org.ivoa.vodml.annotation.VoDml(ref="<xsl:value-of select='concat(ancestor::vo-dml:model/name,":",vodml-id)'/>", type=org.ivoa.vodml.annotation.VodmlType.<xsl:value-of select='name(.)'/>)
 </xsl:template>


</xsl:stylesheet>
